<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Super Mario Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #5c94fc;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      #game-container {
        position: relative;
        width: 800px;
        height: 600px;
        margin: 20px auto;
        border: 3px solid #000;
        background: linear-gradient(to bottom, #5c94fc 0%, #87ceeb 100%);
      }

      #game-canvas {
        display: block;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
        z-index: 1000;
      }

      #game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        display: none;
        z-index: 1000;
      }

      /* Audio enable overlay */
      #audio-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1500;
        cursor: pointer;
      }

      #audio-message {
        background-color: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        font-size: 18px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        max-width: 500px;
      }

      #audio-message h2 {
        margin-top: 0;
        color: #ff6b35;
      }

      #audio-message p {
        margin-bottom: 20px;
      }

      .song-selection {
        margin: 20px 0;
        text-align: left;
      }

      .song-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        margin: 8px 0;
        background-color: #f8f9fa;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 16px;
      }

      .song-option:hover {
        background-color: #e3f2fd;
        border-color: #2196f3;
      }

      .song-option.selected {
        background-color: #2196f3;
        color: white;
        border-color: #1976d2;
      }

      .song-option.selected:hover {
        background-color: #1976d2;
      }

      .song-info {
        flex-grow: 1;
      }

      .song-name {
        font-weight: bold;
        font-size: 16px;
      }

      .song-description {
        font-size: 14px;
        opacity: 0.8;
      }

      .song-option.selected .song-description {
        opacity: 0.9;
      }

      /* Difficulty Selection */
      .difficulty-selection {
        margin: 20px 0;
      }

      .difficulty-label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }

      .difficulty-options {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .difficulty-btn {
        padding: 12px 24px;
        border: 3px solid #ddd;
        border-radius: 12px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s ease;
        background: linear-gradient(to bottom, #fff 0%, #f0f0f0 100%);
      }

      .difficulty-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .difficulty-btn.easy {
        border-color: #4caf50;
        color: #4caf50;
      }

      .difficulty-btn.easy.selected {
        background: linear-gradient(to bottom, #66bb6a 0%, #4caf50 100%);
        color: white;
        border-color: #388e3c;
      }

      .difficulty-btn.medium {
        border-color: #ff9800;
        color: #ff9800;
      }

      .difficulty-btn.medium.selected {
        background: linear-gradient(to bottom, #ffb74d 0%, #ff9800 100%);
        color: white;
        border-color: #f57c00;
      }

      .difficulty-btn.hard {
        border-color: #f44336;
        color: #f44336;
      }

      .difficulty-btn.hard.selected {
        background: linear-gradient(to bottom, #ef5350 0%, #f44336 100%);
        color: white;
        border-color: #d32f2f;
      }

      .difficulty-info {
        font-size: 12px;
        color: #666;
        margin-top: 8px;
      }

      #enable-audio-btn {
        background-color: #ff6b35;
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        margin-top: 20px;
      }

      #enable-audio-btn:hover {
        background-color: #ff5722;
      }

      /* Touch Controls for Mobile/iPad */
      #touch-controls {
        position: fixed;
        bottom: 40px;
        left: 0;
        right: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 30px;
        z-index: 2000;
        pointer-events: none;
      }

      .touch-button {
        width: 90px;
        height: 90px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.8);
        border: 4px solid #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        color: white;
        font-size: 28px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        pointer-events: auto;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        transition: all 0.1s ease;
        position: relative;
      }

      .touch-button:active {
        background-color: rgba(255, 200, 50, 0.9);
        color: black;
        transform: scale(0.92);
        border-color: #ffcc00;
      }

      .left-controls {
        display: flex;
        gap: 15px;
        pointer-events: none;
      }

      #jump-button {
        width: 110px;
        height: 110px;
        font-size: 22px;
        border-radius: 20px;
      }

      /* Make controls more visible on all devices */
      @media (max-width: 767px) {
        .touch-button {
          width: 100px;
          height: 100px;
          font-size: 32px;
        }

        #jump-button {
          width: 120px;
          height: 120px;
          font-size: 24px;
        }
      }

      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
      }

      button:hover {
        background-color: #45a049;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Time: <span id="time">400</span></div>
        <div id="difficulty-display" style="font-size: 12px; opacity: 0.8">
          Difficulty: <span id="current-difficulty">Easy</span>
        </div>
        <div
          id="boss-warning"
          style="display: none; color: red; font-weight: bold"
        >
          ‚ö†Ô∏è BOSS APPROACHING! ‚ö†Ô∏è
        </div>
        <div id="boss-health" style="display: none">
          Boss Health: <span id="boss-health-value">5</span>
        </div>
        <div
          id="victory-message"
          style="display: none; color: gold; font-weight: bold; font-size: 18px"
        >
          üéâ VICTORY! You defeated Bowser! üéâ<br />
          You completed the level!
        </div>
      </div>
      <div id="game-over">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">Play Again</button>
      </div>

      <!-- Audio Enable Overlay -->
      <div id="audio-overlay">
        <div id="audio-message">
          <h2>üéµ Choose Your Soundtrack</h2>
          <p>
            Select your favorite background music and enable sound effects for
            the best gaming experience!
          </p>

          <div class="song-selection">
            <div class="song-option selected" data-index="0">
              <div class="song-info">
                <div class="song-name">üé≠ Game of Thrones</div>
                <div class="song-description">Epic orchestral soundtrack</div>
              </div>
            </div>

            <div class="song-option" data-index="1">
              <div class="song-info">
                <div class="song-name">üçÑ Super Mario</div>
                <div class="song-description">Classic 8-bit adventure</div>
              </div>
            </div>

            <div class="song-option" data-index="2">
              <div class="song-info">
                <div class="song-name">üïµÔ∏è James Bond</div>
                <div class="song-description">Classic spy thriller theme</div>
              </div>
            </div>

            <div class="song-option" data-index="3">
              <div class="song-info">
                <div class="song-name">üé¨ Mission Impossible</div>
                <div class="song-description">High-stakes action music</div>
              </div>
            </div>
          </div>

          <div class="difficulty-selection">
            <div class="difficulty-label">‚öîÔ∏è Select Difficulty</div>
            <div class="difficulty-options">
              <div class="difficulty-btn easy selected" data-difficulty="easy">
                üå± Easy
              </div>
              <div class="difficulty-btn medium" data-difficulty="medium">
                ‚ö° Medium
              </div>
              <div class="difficulty-btn hard" data-difficulty="hard">
                üî• Hard
              </div>
            </div>
            <div class="difficulty-info" id="difficulty-info">
              Fewer enemies, slower speed, less obstacles
            </div>
          </div>

          <button id="enable-audio-btn">üé∂ Start Game with Sound</button>
        </div>
      </div>

      <!-- Touch Controls for Mobile/iPad -->
      <div id="touch-controls">
        <div class="left-controls">
          <div id="left-button" class="touch-button">‚Üê</div>
          <div id="right-button" class="touch-button">‚Üí</div>
        </div>
        <div id="jump-button" class="touch-button">JUMP</div>
      </div>
    </div>

    <script>
      // Audio system
      let audioContext;
      let backgroundMusic;
      let currentAudio = null;

      // Available soundtracks
      const soundtracks = [
        {
          name: "Game of Thrones",
          file: "game-of-thrones-soundtrack.mp3",
          description: "Epic orchestral soundtrack",
        },
        {
          name: "Super Mario",
          file: "super-mario-soundtrack.mp3",
          description: "Classic 8-bit adventure",
        },
        {
          name: "James Bond",
          file: "james-bond-soundtrack.mp3",
          description: "Classic spy thriller theme",
        },
        {
          name: "Mission Impossible",
          file: "mission-impossible-soundtrack.mp3",
          description: "High-stakes action music",
        },
      ];

      let selectedSongIndex = 0; // Default to first song
      let selectedDifficulty = "easy"; // Default difficulty

      // Difficulty configurations
      const difficultyConfig = {
        easy: {
          enemySpawnRate: 0.6, // Fewer enemies
          enemySpeedMultiplier: 0.7, // Slower enemies
          dragonChanceBase: 0.05, // Less dragons
          dragonChanceMax: 0.25,
          spikeSpawnRate: 0.1, // Few spikes
          rockSpawnRate: 0.05, // Rare falling rocks
          lavaWidth: 48, // Smaller lava
          spawnGapBase: 350, // More space between enemies
          spawnGapReduction: 80,
          initialEnemyCount: 3,
          description: "Fewer enemies, slower speed, less obstacles",
        },
        medium: {
          enemySpawnRate: 1.0,
          enemySpeedMultiplier: 1.0,
          dragonChanceBase: 0.1,
          dragonChanceMax: 0.4,
          spikeSpawnRate: 0.2,
          rockSpawnRate: 0.1,
          lavaWidth: 64,
          spawnGapBase: 250,
          spawnGapReduction: 100,
          initialEnemyCount: 6,
          description: "Balanced challenge with moderate obstacles",
        },
        hard: {
          enemySpawnRate: 1.5, // More enemies
          enemySpeedMultiplier: 1.4, // Faster enemies
          dragonChanceBase: 0.2, // More dragons
          dragonChanceMax: 0.6,
          spikeSpawnRate: 0.35, // Many spikes
          rockSpawnRate: 0.2, // Frequent falling rocks
          lavaWidth: 96, // Larger lava
          spawnGapBase: 150, // Enemies close together
          spawnGapReduction: 50,
          initialEnemyCount: 10,
          description: "Many enemies, fast pace, dangerous obstacles",
        },
      };

      // Get current difficulty settings
      function getDifficulty() {
        return difficultyConfig[selectedDifficulty];
      }

      // Initialize audio
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          // Initialize all audio files
          soundtracks.forEach((track) => {
            track.audio = new Audio(track.file);
            track.audio.loop = true;
            track.audio.volume = 0.3;
          });
        } catch (e) {
          console.log("Web Audio API not supported");
        }
      }

      // Play a simple beep sound
      function playBeep(frequency, duration, type = "square") {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + duration
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      }

      // Play Mario jump sound
      function playJumpSound() {
        playBeep(523, 0.1); // C5
        setTimeout(() => playBeep(659, 0.1), 50); // E5
      }

      // Play coin/power-up collection sound
      function playCoinSound() {
        playBeep(800, 0.1);
        setTimeout(() => playBeep(1000, 0.1), 50);
        setTimeout(() => playBeep(1200, 0.1), 100);
      }

      // Play enemy defeat sound
      function playEnemyDefeatSound() {
        playBeep(200, 0.2);
        setTimeout(() => playBeep(150, 0.2), 100);
      }

      // Play brick break sound
      function playBreakSound() {
        playBeep(100, 0.1, "sawtooth");
        setTimeout(() => playBeep(80, 0.1, "sawtooth"), 50);
        setTimeout(() => playBeep(60, 0.2, "sawtooth"), 100);
      }

      // Play power-up sound
      function playPowerUpSound() {
        playBeep(600, 0.1);
        setTimeout(() => playBeep(700, 0.1), 50);
        setTimeout(() => playBeep(800, 0.1), 100);
        setTimeout(() => playBeep(900, 0.2), 150);
      }

      // Play game over sound
      function playGameOverSound() {
        // Descending notes
        const notes = [400, 350, 300, 250, 200, 150];
        notes.forEach((freq, index) => {
          setTimeout(() => playBeep(freq, 0.3), index * 100);
        });
      }

      // Play boss entrance sound
      function playBossEntranceSound() {
        playBeep(100, 0.3, "sawtooth");
        setTimeout(() => playBeep(150, 0.3, "sawtooth"), 100);
        setTimeout(() => playBeep(200, 0.5, "sawtooth"), 200);
      }

      // Play spike hit sound
      function playSpikeSound() {
        playBeep(150, 0.15, "sawtooth");
        setTimeout(() => playBeep(100, 0.2, "sawtooth"), 50);
      }

      // Play falling rock warning sound
      function playRockWarningSound() {
        playBeep(300, 0.1);
        setTimeout(() => playBeep(350, 0.1), 100);
      }

      // Background music - plays selected soundtrack
      function startBackgroundMusic() {
        const selectedTrack = soundtracks[selectedSongIndex];
        if (selectedTrack && selectedTrack.audio) {
          // Stop any currently playing audio
          stopBackgroundMusic();
          // Play the selected soundtrack
          currentAudio = selectedTrack.audio;
          currentAudio.play().catch((e) => {
            console.log("Audio play failed:", e);
            // Fallback to generated music if MP3 fails to load
            fallbackToGeneratedMusic();
          });
        } else {
          // Fallback to generated music
          fallbackToGeneratedMusic();
        }
      }

      function fallbackToGeneratedMusic() {
        if (audioContext && !backgroundMusic) {
          let noteIndex = 0;
          const melody = [
            330, 330, 330, 262, 330, 392, 196, 262, 196, 165, 220, 247, 233,
            220, 196, 330, 349, 392, 330, 262, 294, 247, 262, 196, 165, 220,
            247, 233, 220, 196, 330, 392, 440, 392, 330, 262, 294, 247, 349,
            330, 262, 294, 247, 196, 165, 220, 247,
          ];

          backgroundMusic = setInterval(() => {
            if (noteIndex < melody.length) {
              playBeep(melody[noteIndex], 0.15, "triangle");
              noteIndex++;
            } else {
              noteIndex = 0;
            }
          }, 200);
        }
      }

      function stopBackgroundMusic() {
        // Stop currently playing soundtrack
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio = null;
        }
        // Stop generated music fallback
        if (backgroundMusic) {
          clearInterval(backgroundMusic);
          backgroundMusic = null;
        }
      }

      // Function to select a song
      function selectSong(index) {
        if (index >= 0 && index < soundtracks.length) {
          selectedSongIndex = index;
          // Update visual selection
          updateSongSelection();
        }
      }

      function updateSongSelection() {
        // Remove selected class from all options
        document.querySelectorAll(".song-option").forEach((option) => {
          option.classList.remove("selected");
        });
        // Add selected class to current selection
        const selectedOption = document.querySelector(
          `.song-option[data-index="${selectedSongIndex}"]`
        );
        if (selectedOption) {
          selectedOption.classList.add("selected");
        }
      }

      // Game constants
      const CANVAS_WIDTH = 800;
      const CANVAS_HEIGHT = 600;
      const GRAVITY = 0.5;
      const JUMP_FORCE = -12;
      const MOVE_SPEED = 5;
      const GROUND_LEVEL = 500;

      // Game variables
      let canvas, ctx;
      let gameRunning = true;
      let score = 0;
      let lives = 3;
      let timeLeft = 400;
      let gameLoop;

      // Camera system
      let cameraX = 0;

      // Player (Mario)
      let mario = {
        x: 50, // Safe starting position
        y: GROUND_LEVEL - 32,
        width: 32,
        height: 32,
        velocityX: 0,
        velocityY: 0,
        onGround: false,
        facing: "right",
        powerLevel: 0, // 0: small, 1: big, 2: fire
        animationFrame: 0,
        animationTimer: 0,
      };

      // Platforms and level elements
      let platforms = [
        // Ground
        {
          x: 0,
          y: GROUND_LEVEL,
          width: CANVAS_WIDTH,
          height: 100,
          type: "ground",
        },

        // Platforms
        { x: 300, y: 400, width: 150, height: 20, type: "platform" },
        { x: 500, y: 350, width: 100, height: 20, type: "platform" },
        { x: 650, y: 300, width: 100, height: 20, type: "platform" },
        // Challenging platforms for level progression
        { x: 850, y: 250, width: 80, height: 20, type: "platform" },
        { x: 950, y: 200, width: 80, height: 20, type: "platform" },
        { x: 1050, y: 280, width: 80, height: 20, type: "platform" },
        { x: 1150, y: 220, width: 80, height: 20, type: "platform" },
        { x: 1300, y: 350, width: 120, height: 20, type: "platform" }, // Boss platform

        // Bricks
        {
          x: 350,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 382,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 414,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        // More challenging bricks
        {
          x: 850,
          y: 218,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 882,
          y: 218,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 1050,
          y: 248,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 1300,
          y: 318,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },

        // Question blocks
        {
          x: 446,
          y: 368,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        {
          x: 550,
          y: 318,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        // More challenging question blocks
        {
          x: 950,
          y: 168,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        {
          x: 1150,
          y: 188,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },

        // Pipes
        { x: 700, y: 468, width: 64, height: 32, type: "pipe" },
      ];

      // Enemies - will be populated based on difficulty
      let enemies = [];

      // Bullet Bills (rockets)
      let bulletBills = [];

      // Bill Blasters (cannons that shoot Bullet Bills)
      let billBlasters = [];

      // Initial enemies based on difficulty (called after game starts)
      function initializeEnemies() {
        const difficulty = getDifficulty();
        enemies = [];

        // Base enemies - always present
        const baseEnemies = [
          { x: 400, type: "goomba" },
          { x: 600, type: "goomba" },
          { x: 750, type: "koopa" },
        ];

        // Additional enemies based on difficulty
        const additionalEnemies = [
          { x: 900, type: "goomba" },
          { x: 1000, type: "koopa" },
          { x: 1100, type: "goomba" },
          { x: 1200, type: "koopa" },
          { x: 1300, type: "goomba" },
          { x: 1400, type: "koopa" },
          { x: 1500, type: "goomba" },
        ];

        // Spawn base enemies
        baseEnemies.forEach((e) => {
          const speed = 1 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: e.x,
            y: GROUND_LEVEL - 32,
            width: 32,
            height: 32,
            velocityX: Math.random() < 0.5 ? -speed : speed,
            type: e.type,
            alive: true,
          });
        });

        // Spawn additional enemies based on difficulty count
        const extraCount = difficulty.initialEnemyCount - baseEnemies.length;
        for (
          let i = 0;
          i < Math.max(0, extraCount) && i < additionalEnemies.length;
          i++
        ) {
          const e = additionalEnemies[i];
          const speed = 1 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: e.x,
            y: GROUND_LEVEL - 32,
            width: 32,
            height: 32,
            velocityX: Math.random() < 0.5 ? -speed : speed,
            type: e.type,
            alive: true,
          });
        }

        // Dragon enemy - only on medium and hard
        if (selectedDifficulty !== "easy") {
          const dragonSpeed = 2 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: 550,
            y: 200,
            width: 48,
            height: 32,
            velocityX: dragonSpeed,
            velocityY: 0,
            type: "dragon",
            alive: true,
            health: 2,
            flightTimer: 0,
            fireTimer: 0,
          });
        }

        // Boss enemy - always present but harder on higher difficulties
        enemies.push({
          x: 1600,
          y: GROUND_LEVEL - 64,
          width: 64,
          height: 64,
          velocityX: 0,
          type: "bowser",
          alive: true,
          health:
            selectedDifficulty === "easy"
              ? 3
              : selectedDifficulty === "medium"
              ? 5
              : 8,
          directionChangeTimer: 0,
          entered: false,
        });
      }

      // Power-ups
      let powerUps = [];

      // Particles for effects
      let particles = [];

      // Lava hazards - initialized based on difficulty
      let lavaHazards = [];

      // Initialize lava based on difficulty (called in initializeObstacles)
      function initializeLava() {
        lavaHazards = [];
        // Only add lava on medium and hard difficulties
        if (selectedDifficulty !== "easy") {
          lavaHazards.push({
            x: 530, // Positioned under the dragon at x=550
            y: GROUND_LEVEL - 10,
            width: selectedDifficulty === "hard" ? 120 : 88,
            height: 20,
            type: "lava",
            damage: 1,
            timer: 1800,
          });
        }
      }

      // Obstacles (spikes, falling rocks)
      let obstacles = [];
      let fallingRocks = [];

      // Input handling
      let keys = {};

      // Initialize game
      function init() {
        canvas = document.getElementById("game-canvas");
        ctx = canvas.getContext("2d");

        // Initialize audio
        initAudio();

        // Event listeners
        document.addEventListener("keydown", (e) => {
          keys[e.code] = true;
        });

        document.addEventListener("keyup", (e) => {
          keys[e.code] = false;
        });

        // Touch controls for mobile/iPad
        setupTouchControls();

        // Don't start background music automatically - wait for user interaction
        // startBackgroundMusic(); // Commented out to require user interaction

        // Start game loop
        gameLoop = setInterval(update, 1000 / 60); // 60 FPS
        setInterval(updateTimer, 1000); // Update timer every second
      }

      // Main game update loop
      function update() {
        if (!gameRunning) return;

        handleInput();
        updateMario();
        updateEnemies();
        updatePowerUps();
        updateParticles();
        updateLava();
        updateObstacles(); // Update spikes and falling rocks
        updateBulletBills(); // Update Bullet Bills
        generateGround(); // Generate infinite ground
        generatePlatforms(); // Procedural generation
        updateFlyingPlatforms(); // Update flying platform positions
        generateEnemies(); // Procedural generation
        generateObstacles(); // Generate spikes and rocks
        generateBillBlasters(); // Generate Bill Blasters
        checkCollisions();
        render();

        // Camera follow - smooth following for infinite level
        const targetCameraX = Math.max(0, mario.x - CANVAS_WIDTH / 2);
        // No max camera limit - infinite scrolling!
        cameraX = targetCameraX;
      }

      // Handle player input
      function handleInput() {
        // Horizontal movement
        if (keys["ArrowLeft"] || keys["KeyA"]) {
          mario.velocityX = -MOVE_SPEED;
          mario.facing = "left";
        } else if (keys["ArrowRight"] || keys["KeyD"]) {
          mario.velocityX = MOVE_SPEED;
          mario.facing = "right";
        } else {
          mario.velocityX = 0;
        }

        // Jumping
        if (
          (keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) &&
          mario.onGround
        ) {
          mario.velocityY = JUMP_FORCE;
          mario.onGround = false;
          playJumpSound();
        }
      }

      // Update Mario
      function updateMario() {
        // Apply gravity
        mario.velocityY += GRAVITY;

        // Update position
        mario.x += mario.velocityX;
        mario.y += mario.velocityY;

        // Reset onGround status
        mario.onGround = false;

        // Ground collision
        if (mario.y + mario.height >= GROUND_LEVEL) {
          mario.y = GROUND_LEVEL - mario.height;
          mario.velocityY = 0;
          mario.onGround = true;
        }

        // Platform collisions
        platforms.forEach((platform) => {
          if (checkCollision(mario, platform)) {
            if (mario.velocityY > 0 && mario.y < platform.y) {
              // Landing on platform
              mario.y = platform.y - mario.height;
              mario.velocityY = 0;
              mario.onGround = true;
            } else if (mario.velocityY < 0 && mario.y > platform.y) {
              // Hitting platform from below
              mario.y = platform.y + platform.height;
              mario.velocityY = 0;
            }

            // Handle brick/question block interactions
            if (
              platform.type === "brick" &&
              mario.velocityY < 0 &&
              platform.breakable
            ) {
              platform.breakable = false;
              score += 50;
              playBreakSound();
            } else if (
              platform.type === "question" &&
              mario.velocityY < 0 &&
              !platform.used
            ) {
              platform.used = true;
              spawnPowerUp(platform.x, platform.y - 32);
              score += 100;
              playCoinSound();
            }

            // Portal interactions are now only for enemies, not Mario
          }
        });

        // Keep Mario in bounds
        if (mario.x < 0) mario.x = 0;
        // No right boundary - infinite level!
      }

      // Update enemies
      function updateEnemies() {
        enemies.forEach((enemy, index) => {
          if (!enemy.alive) return;

          enemy.x += enemy.velocityX;
          enemy.y += enemy.velocityY; // Update y position for flying enemies

          // Simple AI - reverse direction at platform edges
          let onPlatform = false;
          platforms.forEach((platform) => {
            if (
              enemy.x + enemy.width > platform.x &&
              enemy.x < platform.x + platform.width &&
              enemy.y + enemy.height >= platform.y - 5 &&
              enemy.y + enemy.height <= platform.y + 10
            ) {
              onPlatform = true;
            }
          });

          if (!onPlatform) {
            enemy.velocityX *= -1;
          }

          // Special dragon AI
          if (enemy.type === "dragon") {
            enemy.flightTimer++;
            enemy.fireTimer--;

            // Flying pattern - sinusoidal vertical movement
            enemy.velocityY = Math.sin(enemy.flightTimer * 0.05) * 2;

            // Horizontal movement with occasional direction changes
            if (enemy.flightTimer % 200 === 0) {
              enemy.velocityX *= -1; // Reverse direction
            }

            // Fire breath every few seconds
            if (enemy.flightTimer % 300 === 0) {
              enemy.fireTimer = 20; // Fire for 20 frames
            }

            // Keep dragon in air
            if (enemy.y < 100) enemy.y = 100;
            if (enemy.y > 300) enemy.y = 300;
          }

          // Special boss AI
          if (enemy.type === "bowser") {
            // Boss entrance - move onto screen when Mario gets close
            if (!enemy.entered && mario.x > 1200) {
              enemy.entered = true;
              enemy.velocityX = -2; // Start moving left onto the screen
              playBossEntranceSound(); // Dramatic entrance sound
              createTeleportParticles(enemy.x, enemy.y); // Entrance particles
            }

            // Only activate aggressive AI after boss has entered
            if (enemy.entered) {
              enemy.directionChangeTimer++;
              if (enemy.directionChangeTimer > 120) {
                // Change direction every 2 seconds
                enemy.velocityX *= -1;
                enemy.directionChangeTimer = 0;
              }
              // Boss is faster and more aggressive
              enemy.velocityX = enemy.velocityX > 0 ? 3 : -3;
            }
          }

          // Keep enemies in bounds - remove if too far from camera
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (enemy.x < cameraLeft || enemy.x > cameraRight) {
            enemies.splice(index, 1);
          }
        });
      }

      // Procedural generation system
      let nextPlatformX = 1700; // Start generating after initial platforms
      let nextEnemyX = 1800;
      let nextGroundX = 800; // Start extending ground
      let nextObstacleX = 500; // Start generating obstacles early
      let nextBlasterX = 600; // Start generating Bill Blasters early

      // Generate infinite ground
      function generateGround() {
        while (nextGroundX < mario.x + CANVAS_WIDTH * 2) {
          platforms.push({
            x: nextGroundX,
            y: GROUND_LEVEL,
            width: 800, // Overlapping chunks for seamless ground
            height: 100,
            type: "ground",
          });
          nextGroundX += 800;
        }
      }

      // Generate random platforms as Mario progresses
      function generatePlatforms() {
        // Only generate if Mario is approaching
        while (nextPlatformX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextPlatformX;

          // Calculate difficulty based on distance
          const distanceTraveled = x;
          const difficultyFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Platform height gets more varied with distance
          const heightVariation = 150 + difficultyFactor * 100; // 150 -> 250
          const y = 250 + Math.random() * heightVariation;

          // Flying platforms become more common (10% -> 30%)
          const flyingChance = 0.1 + difficultyFactor * 0.2;
          const isFlying = Math.random() < flyingChance;

          // Flying platforms move faster and more erratically at higher difficulties
          const flightSpeed = isFlying
            ? 0.02 + Math.random() * 0.03 + difficultyFactor * 0.02
            : 0;
          const flightRadius = isFlying
            ? 50 + Math.random() * 100 + difficultyFactor * 50
            : 0;

          const platformType = Math.random();

          // Increased spawn rates for more consistent blocks
          if (platformType < 0.35) {
            // Floating platform (35%)
            // Platforms get smaller with distance (harder to land on)
            const platformWidth = 180 - difficultyFactor * 60; // 180 -> 120
            platforms.push({
              x: x,
              y: y,
              width: platformWidth,
              height: 20,
              type: "platform",
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.55) {
            // Brick (20%)
            platforms.push({
              x: x,
              y: y,
              width: 32,
              height: 32,
              type: "brick",
              breakable: true,
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.6,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.75) {
            // Question block (20%)
            platforms.push({
              x: x,
              y: y,
              width: 32,
              height: 32,
              type: "question",
              used: false,
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.6,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.85) {
            // Pipe on ground (10%)
            platforms.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 64,
              height: 32,
              type: "pipe",
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.8,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          }
          // 15% chance of nothing - gaps get wider with difficulty

          // Platform spacing increases with difficulty (gaps get wider)
          const minGap = 120 + difficultyFactor * 30; // 120 -> 150
          const gapVariation = 180 + difficultyFactor * 70; // 180 -> 250
          nextPlatformX += minGap + Math.random() * gapVariation;
        }
      }

      // Update flying platforms - make them move in circular patterns
      function updateFlyingPlatforms() {
        platforms.forEach((platform) => {
          if (platform.flying) {
            // Update flight angle
            platform.flightAngle += platform.flightSpeed;

            // Calculate vertical movement using sine wave
            const verticalOffset =
              Math.sin(platform.flightAngle) * platform.flightRadius;

            // Update platform Y position
            platform.y = platform.originalY + verticalOffset;

            // Optional: Add horizontal movement for more dynamic flying
            // platform.x += Math.cos(platform.flightAngle) * 0.5;
          }
        });
      }

      // Generate random enemies as Mario progresses
      function generateEnemies() {
        const difficulty = getDifficulty();

        // Only generate if Mario is approaching
        while (nextEnemyX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextEnemyX;

          // Calculate difficulty multiplier based on distance traveled
          // Early game (0-1000): mostly easy enemies
          // Mid game (1000-3000): mix of all enemies
          // Late game (3000+): more dragons and harder enemies
          const distanceTraveled = x;
          const distanceFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Adjust spawn rates based on difficulty settings
          const dragonChance =
            difficulty.dragonChanceBase +
            distanceFactor *
              (difficulty.dragonChanceMax - difficulty.dragonChanceBase);
          const koopaChance = 0.3; // stays at 30%
          const goombaChance = 1 - dragonChance - koopaChance;

          const enemyType = Math.random();

          if (enemyType < goombaChance) {
            // Goomba - speed affected by difficulty
            const speed =
              (1 + distanceFactor * 0.5) * difficulty.enemySpeedMultiplier;
            enemies.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 32,
              height: 32,
              velocityX: Math.random() < 0.5 ? -speed : speed,
              type: "goomba",
              alive: true,
            });
          } else if (enemyType < goombaChance + koopaChance) {
            // Koopa - speed affected by difficulty
            const speed =
              (1 + distanceFactor * 0.8) * difficulty.enemySpeedMultiplier;
            enemies.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 32,
              height: 32,
              velocityX: Math.random() < 0.5 ? -speed : speed,
              type: "koopa",
              alive: true,
            });
          } else {
            // Flying dragon with lava underneath - speed and health affected by difficulty
            const dragonY = 150 + Math.random() * 100;
            const speed =
              (2 + distanceFactor * 1) * difficulty.enemySpeedMultiplier;
            const health = 2 + Math.floor(distanceFactor * 2);

            // Calculate lava width for spacing check
            const lavaWidth = difficulty.lavaWidth + distanceFactor * 32;
            const newLavaX = x - 20;

            // Check if this dragon would be too close to existing dragons
            let canSpawnDragon = true;
            for (const hazard of lavaHazards) {
              if (hazard.type === "lava") {
                // Check if this lava hazard overlaps or is too close to existing lava
                // Need at least one lava width of space between lava hazards
                const minDistance = lavaWidth;
                const distance = Math.abs(
                  newLavaX + lavaWidth / 2 - (hazard.x + hazard.width / 2)
                );
                const combinedHalfWidths = (lavaWidth + hazard.width) / 2;

                if (distance < combinedHalfWidths + minDistance) {
                  canSpawnDragon = false;
                  break;
                }
              }
            }

            // Only spawn dragon if there's enough space
            if (canSpawnDragon) {
              enemies.push({
                x: x,
                y: dragonY,
                width: 48,
                height: 32,
                velocityX: Math.random() < 0.5 ? -speed : speed,
                velocityY: 0,
                type: "dragon",
                alive: true,
                health: health,
                flightTimer: 0,
                fireTimer: 0,
              });

              // Add lava underneath the dragon - width based on difficulty
              lavaHazards.push({
                x: newLavaX,
                y: GROUND_LEVEL - 10,
                width: lavaWidth,
                height: 20,
                type: "lava",
                damage: 1,
                timer: 999999, // Lava lasts essentially forever
              });
            } else {
              // If we can't spawn a dragon due to spacing, try spawning a different enemy instead
              // Spawn a goomba instead to maintain enemy density
              enemies.push({
                x: x,
                y: GROUND_LEVEL - 32,
                width: 32,
                height: 32,
                velocityX: Math.random() < 0.5 ? -speed : speed,
                type: "goomba",
                alive: true,
              });
            }
          }

          // Enemy spawn rate based on difficulty settings
          const spawnGap =
            difficulty.spawnGapBase -
            distanceFactor * difficulty.spawnGapReduction;
          nextEnemyX += spawnGap + Math.random() * 150;
        }
      }

      // Update power-ups
      function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const powerUp = powerUps[i];
          powerUp.y += powerUp.velocityY;
          powerUp.velocityY += GRAVITY;

          // Ground collision
          if (powerUp.y + powerUp.height >= GROUND_LEVEL) {
            powerUp.y = GROUND_LEVEL - powerUp.height;
            powerUp.velocityY = 0;
          }

          // Remove power-ups that are off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (powerUp.x < cameraLeft || powerUp.x > cameraRight) {
            powerUps.splice(i, 1);
          }
        }
      }

      // Spawn power-up
      function spawnPowerUp(x, y) {
        powerUps.push({
          x: x,
          y: y,
          width: 32,
          height: 32,
          velocityY: -8,
          type: Math.random() < 0.7 ? "mushroom" : "fireflower",
        });
      }

      // Update particles
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];
          particle.x += particle.velocityX;
          particle.y += particle.velocityY;
          particle.velocityY += 0.1; // Gravity
          particle.life--;

          // Remove dead particles or particles off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (
            particle.life <= 0 ||
            particle.x < cameraLeft ||
            particle.x > cameraRight
          ) {
            particles.splice(i, 1);
          }
        }
      }

      // Update lava hazards
      function updateLava() {
        for (let i = lavaHazards.length - 1; i >= 0; i--) {
          const lava = lavaHazards[i];
          lava.timer--;

          // Remove expired lava or lava off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3;
          if (
            lava.timer <= 0 ||
            lava.x + lava.width < cameraLeft ||
            lava.x > cameraRight
          ) {
            lavaHazards.splice(i, 1);
          }
        }
      }

      // Update obstacles (spikes and falling rocks)
      function updateObstacles() {
        const cameraLeft = cameraX - CANVAS_WIDTH;
        const cameraRight = cameraX + CANVAS_WIDTH * 3;

        // Update spikes - remove off-screen ones
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obstacle = obstacles[i];
          if (
            obstacle.x + obstacle.width < cameraLeft ||
            obstacle.x > cameraRight
          ) {
            obstacles.splice(i, 1);
          }
        }

        // Update falling rocks
        for (let i = fallingRocks.length - 1; i >= 0; i--) {
          const rock = fallingRocks[i];

          // Apply gravity
          rock.velocityY += 0.3;
          rock.y += rock.velocityY;
          rock.rotation += rock.rotationSpeed;

          // Remove rocks that hit the ground or are off-screen
          if (
            rock.y > GROUND_LEVEL ||
            rock.x < cameraLeft ||
            rock.x > cameraRight
          ) {
            // Create impact particles
            if (rock.y > GROUND_LEVEL - 20) {
              for (let j = 0; j < 5; j++) {
                particles.push({
                  x: rock.x + rock.width / 2,
                  y: GROUND_LEVEL,
                  velocityX: (Math.random() - 0.5) * 4,
                  velocityY: -Math.random() * 3,
                  life: 20,
                  color: "#8B4513",
                  size: 3 + Math.random() * 3,
                });
              }
            }
            fallingRocks.splice(i, 1);
          }
        }

        // Spawn new falling rocks near Mario
        const difficulty = getDifficulty();
        if (Math.random() < difficulty.rockSpawnRate * 0.01) {
          // Spawn rock ahead of Mario
          const spawnX = mario.x + CANVAS_WIDTH * 0.5 + Math.random() * 200;
          fallingRocks.push({
            x: spawnX,
            y: -50,
            width: 24 + Math.random() * 16,
            height: 24 + Math.random() * 16,
            velocityY: 1 + Math.random() * 2,
            rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.2,
          });
        }
      }

      // Generate obstacles as Mario progresses
      function generateObstacles() {
        const difficulty = getDifficulty();

        // Generate spikes
        while (nextObstacleX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextObstacleX;

          // Spike spawn based on difficulty
          if (Math.random() < difficulty.spikeSpawnRate) {
            // Create spike trap on ground
            const spikeCount = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < spikeCount; i++) {
              obstacles.push({
                x: x + i * 24,
                y: GROUND_LEVEL - 20,
                width: 24,
                height: 20,
                type: "spike",
              });
            }
          }

          // Increase gap between obstacle spawn points
          nextObstacleX += 200 + Math.random() * 300;
        }
      }

      // Generate Bill Blasters (cannons) as Mario progresses
      function generateBillBlasters() {
        const difficulty = getDifficulty();

        // Easy difficulty has no rockets at all
        if (selectedDifficulty === "easy") {
          return;
        }

        // Only generate if Mario is approaching
        while (nextBlasterX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextBlasterX;

          // Calculate difficulty based on distance
          const distanceTraveled = x;
          const distanceFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Blaster spawn rate based on difficulty
          let baseSpawnChance;
          if (selectedDifficulty === "medium") {
            // Medium: Very low spawn rate, increases slowly
            baseSpawnChance = 0.05 + distanceFactor * 0.05; // 5% -> 10%
          } else {
            // Hard: Low spawn rate, increases moderately
            baseSpawnChance = 0.08 + distanceFactor * 0.08; // 8% -> 16%
          }

          if (Math.random() < baseSpawnChance) {
            // Random placement - can be on ground or elevated
            const placementType = Math.random();
            let y, height;

            if (placementType < 0.5) {
              // Ground-level blaster
              y = GROUND_LEVEL - 48;
              height = 48;
            } else if (placementType < 0.8) {
              // Mid-height blaster
              y = GROUND_LEVEL - 200;
              height = 48;
            } else {
              // High blaster
              y = 150;
              height = 48;
            }

            // Add Bill Blaster
            billBlasters.push({
              x: x,
              y: y,
              width: 48,
              height: height,
              type: "blaster",
              shootTimer: Math.random() * 120 + 60, // Shoot every 60-180 frames
              shootCooldown:
                selectedDifficulty === "medium"
                  ? 300 - distanceFactor * 30
                  : 180 - distanceFactor * 30, // Medium shoots much slower, Hard shoots slower
            });
          }

          // Spacing between potential blaster spawns (larger gaps to reduce frequency)
          const baseSpacing = selectedDifficulty === "medium" ? 600 : 450;
          const spacingVariation = selectedDifficulty === "medium" ? 800 : 600;
          nextBlasterX += baseSpacing + Math.random() * spacingVariation;
        }
      }

      // Update Bullet Bills
      function updateBulletBills() {
        const cameraLeft = cameraX - CANVAS_WIDTH;
        const cameraRight = cameraX + CANVAS_WIDTH * 3;
        const difficulty = getDifficulty();

        // Update existing Bullet Bills
        for (let i = bulletBills.length - 1; i >= 0; i--) {
          const bullet = bulletBills[i];

          // Move Bullet Bill
          bullet.x += bullet.velocityX;

          // Remove if off-screen
          if (bullet.x < cameraLeft || bullet.x > cameraRight) {
            bulletBills.splice(i, 1);
            continue;
          }
        }

        // Update Bill Blasters and spawn new Bullet Bills
        for (let i = billBlasters.length - 1; i >= 0; i--) {
          const blaster = billBlasters[i];

          // Remove blasters that are too far off-screen
          if (
            blaster.x + blaster.width < cameraLeft ||
            blaster.x > cameraRight
          ) {
            billBlasters.splice(i, 1);
            continue;
          }

          // Update shoot timer
          blaster.shootTimer--;

          // Spawn Bullet Bill when timer reaches 0
          if (blaster.shootTimer <= 0 && blaster.x < mario.x + CANVAS_WIDTH) {
            // Only shoot if on screen or close to it
            const distanceTraveled = blaster.x;
            const distanceFactor = Math.min(distanceTraveled / 3000, 1);

            // Determine direction - shoot towards Mario's general direction
            const shootLeft = blaster.x > mario.x;
            // Adjust speed based on difficulty - medium is slower than base
            let speedMultiplier = difficulty.enemySpeedMultiplier;
            if (selectedDifficulty === "medium") {
              speedMultiplier *= 0.8; // Medium rockets are 20% slower
            }
            const speed = (4 + distanceFactor * 2) * speedMultiplier;

            // Create Bullet Bill
            bulletBills.push({
              x: blaster.x + (shootLeft ? -32 : blaster.width),
              y: blaster.y + blaster.height / 2 - 16, // Center on blaster
              width: 32,
              height: 32,
              velocityX: shootLeft ? -speed : speed,
              type: "bullet",
              alive: true,
            });

            // Play shoot sound
            playBeep(200, 0.1, "square");

            // Reset timer
            blaster.shootTimer = blaster.shootCooldown;
          }
        }
      }

      // Check collisions
      function checkCollisions() {
        // Mario vs enemies
        enemies.forEach((enemy, enemyIndex) => {
          if (enemy.alive && checkCollision(mario, enemy)) {
            if (mario.velocityY > 0 && mario.y < enemy.y) {
              // Mario jumped on enemy
              if (enemy.type === "bowser") {
                // Boss takes multiple hits
                enemy.health--;
                mario.velocityY = JUMP_FORCE * 0.8; // Higher bounce off boss
                score += 500; // More points for hitting boss
                playBreakSound(); // Sound for damaging boss

                // Update boss health display
                document.getElementById("boss-health-value").textContent =
                  enemy.health;
                document.getElementById("boss-health").style.display = "block";

                if (enemy.health <= 0) {
                  enemy.alive = false;
                  score += 5000; // Bonus for defeating boss
                  playPowerUpSound(); // Victory sound
                  document.getElementById("boss-health").style.display = "none";
                  document.getElementById("boss-warning").style.display =
                    "none";
                  document.getElementById("victory-message").style.display =
                    "block";
                }
              } else if (enemy.type === "dragon") {
                // Dragon takes 2 hits to defeat
                enemy.health = (enemy.health || 2) - 1;
                mario.velocityY = JUMP_FORCE * 0.7; // Bounce off dragon
                score += 300; // Points for hitting dragon

                if (enemy.health <= 0) {
                  enemy.alive = false;
                  score += 1000; // Bonus for defeating dragon
                  playPowerUpSound(); // Victory sound
                } else {
                  playBreakSound(); // Sound for damaging dragon
                }
              } else {
                // Regular enemies die in one hit
                enemy.alive = false;
                mario.velocityY = JUMP_FORCE * 0.5; // Small bounce
                score += 100;
                playEnemyDefeatSound();
              }
            } else {
              // Mario hit by enemy
              if (enemy.type === "dragon" && enemy.fireTimer > 0) {
                // Dragon fire is extra dangerous - double damage
                loseLife();
                loseLife();
              } else {
                loseLife();
              }
            }
          }
        });

        // Mario vs lava hazards
        lavaHazards.forEach((lava) => {
          if (checkCollision(mario, lava)) {
            // Lava damage - lose life immediately
            loseLife();
            // Add burn particles
            for (let i = 0; i < 8; i++) {
              particles.push({
                x: mario.x + 16,
                y: mario.y + 16,
                velocityX: (Math.random() - 0.5) * 4,
                velocityY: -Math.random() * 2,
                life: 20,
                color: Math.random() < 0.5 ? "#FF4500" : "#FFD700",
                size: 3 + Math.random() * 3,
              });
            }
          }
        });

        // Mario vs spikes
        obstacles.forEach((obstacle) => {
          if (obstacle.type === "spike" && checkCollision(mario, obstacle)) {
            playSpikeSound();
            loseLife();
            // Add spike hit particles
            for (let i = 0; i < 6; i++) {
              particles.push({
                x: mario.x + 16,
                y: mario.y + mario.height,
                velocityX: (Math.random() - 0.5) * 3,
                velocityY: -Math.random() * 4,
                life: 15,
                color: "#A0A0A0",
                size: 2 + Math.random() * 2,
              });
            }
          }
        });

        // Mario vs falling rocks
        for (let i = fallingRocks.length - 1; i >= 0; i--) {
          const rock = fallingRocks[i];
          if (checkCollision(mario, rock)) {
            playBreakSound();
            loseLife();
            fallingRocks.splice(i, 1);
            // Add rock break particles
            for (let j = 0; j < 8; j++) {
              particles.push({
                x: rock.x + rock.width / 2,
                y: rock.y + rock.height / 2,
                velocityX: (Math.random() - 0.5) * 5,
                velocityY: (Math.random() - 0.5) * 5,
                life: 25,
                color: Math.random() < 0.5 ? "#8B4513" : "#A0522D",
                size: 4 + Math.random() * 4,
              });
            }
          }
        }

        // Mario vs Bullet Bills
        for (let i = bulletBills.length - 1; i >= 0; i--) {
          const bullet = bulletBills[i];
          if (bullet.alive && checkCollision(mario, bullet)) {
            // Check if Mario jumped on the Bullet Bill
            if (mario.velocityY > 0 && mario.y < bullet.y) {
              // Defeated Bullet Bill by jumping on it
              bullet.alive = false;
              bulletBills.splice(i, 1);
              mario.velocityY = JUMP_FORCE * 0.5; // Small bounce
              score += 200; // More points for defeating Bullet Bill
              playEnemyDefeatSound();

              // Add explosion particles
              for (let j = 0; j < 10; j++) {
                particles.push({
                  x: bullet.x + bullet.width / 2,
                  y: bullet.y + bullet.height / 2,
                  velocityX: (Math.random() - 0.5) * 6,
                  velocityY: (Math.random() - 0.5) * 6,
                  life: 30,
                  color: Math.random() < 0.5 ? "#FF4500" : "#FFD700",
                  size: 4 + Math.random() * 4,
                });
              }
            } else {
              // Hit by Bullet Bill
              loseLife();
              bullet.alive = false;
              bulletBills.splice(i, 1);

              // Add explosion particles
              for (let j = 0; j < 8; j++) {
                particles.push({
                  x: bullet.x + bullet.width / 2,
                  y: bullet.y + bullet.height / 2,
                  velocityX: (Math.random() - 0.5) * 5,
                  velocityY: (Math.random() - 0.5) * 5,
                  life: 25,
                  color: "#FF0000",
                  size: 3 + Math.random() * 3,
                });
              }
            }
          }
        }

        // Mario vs power-ups
        for (
          let powerUpIndex = powerUps.length - 1;
          powerUpIndex >= 0;
          powerUpIndex--
        ) {
          const powerUp = powerUps[powerUpIndex];
          if (checkCollision(mario, powerUp)) {
            powerUps.splice(powerUpIndex, 1);

            if (powerUp.type === "mushroom") {
              mario.powerLevel = Math.min(mario.powerLevel + 1, 2);
              score += 1000;
              playPowerUpSound();
            } else if (powerUp.type === "fireflower") {
              mario.powerLevel = 2;
              score += 1000;
              playPowerUpSound();
            }
            break; // Only collect one power-up per frame to prevent issues
          }
        }
      }

      // Collision detection helper
      function checkCollision(obj1, obj2) {
        return (
          obj1.x < obj2.x + obj2.width &&
          obj1.x + obj1.width > obj2.x &&
          obj1.y < obj2.y + obj2.height &&
          obj1.y + obj1.height > obj2.y
        );
      }

      // Lose a life
      function loseLife() {
        lives--;
        document.getElementById("lives").textContent = lives;

        if (lives <= 0) {
          gameOver();
        } else {
          // Reset Mario position
          mario.x = 50; // Updated to match new starting position
          mario.y = GROUND_LEVEL - 32;
          mario.velocityX = 0;
          mario.velocityY = 0;
        }
      }

      // Game over
      function gameOver() {
        gameRunning = false;
        stopBackgroundMusic();
        playGameOverSound();
        document.getElementById("final-score").textContent = score;
        document.getElementById("game-over").style.display = "block";
      }

      // Restart game
      function restartGame() {
        location.reload();
      }

      // Touch controls setup
      function setupTouchControls() {
        const leftButton = document.getElementById("left-button");
        const rightButton = document.getElementById("right-button");
        const jumpButton = document.getElementById("jump-button");

        // Touch/mouse events for left movement
        leftButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["ArrowLeft"] = true;
          keys["KeyA"] = true;
        });
        leftButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["ArrowLeft"] = false;
          keys["KeyA"] = false;
        });
        leftButton.addEventListener("mousedown", () => {
          keys["ArrowLeft"] = true;
          keys["KeyA"] = true;
        });
        leftButton.addEventListener("mouseup", () => {
          keys["ArrowLeft"] = false;
          keys["KeyA"] = false;
        });

        // Touch/mouse events for right movement
        rightButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["ArrowRight"] = true;
          keys["KeyD"] = true;
        });
        rightButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["ArrowRight"] = false;
          keys["KeyD"] = false;
        });
        rightButton.addEventListener("mousedown", () => {
          keys["ArrowRight"] = true;
          keys["KeyD"] = true;
        });
        rightButton.addEventListener("mouseup", () => {
          keys["ArrowRight"] = false;
          keys["KeyD"] = false;
        });

        // Touch/mouse events for jump
        jumpButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["Space"] = true;
          keys["ArrowUp"] = true;
          keys["KeyW"] = true;
        });
        jumpButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["Space"] = false;
          keys["ArrowUp"] = false;
          keys["KeyW"] = false;
        });
        jumpButton.addEventListener("mousedown", () => {
          keys["Space"] = true;
          keys["ArrowUp"] = true;
          keys["KeyW"] = true;
        });
        jumpButton.addEventListener("mouseup", () => {
          keys["Space"] = false;
          keys["ArrowUp"] = false;
          keys["KeyW"] = false;
        });

        // Prevent default touch behaviors on buttons
        [leftButton, rightButton, jumpButton].forEach((button) => {
          button.addEventListener("touchstart", (e) => e.preventDefault(), {
            passive: false,
          });
          button.addEventListener("touchmove", (e) => e.preventDefault(), {
            passive: false,
          });
          button.addEventListener("touchend", (e) => e.preventDefault(), {
            passive: false,
          });
        });
      }

      // Audio enable overlay
      function hideAudioOverlay() {
        const overlay = document.getElementById("audio-overlay");
        if (overlay) {
          overlay.style.display = "none";
        }
      }

      // Make sure audio works on user interaction (required by browsers)
      let audioStarted = false;

      function enableAudio() {
        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }
        // Start background music on first user interaction
        if (!audioStarted) {
          // Initialize enemies based on selected difficulty
          initializeEnemies();
          // Initialize initial obstacles
          initializeObstacles();
          // Initialize Bill Blasters
          initializeBillBlasters();
          startBackgroundMusic();
          audioStarted = true;
          hideAudioOverlay();
        }
      }

      // Initialize obstacles based on difficulty
      function initializeObstacles() {
        const difficulty = getDifficulty();
        obstacles = [];
        fallingRocks = [];

        // Initialize lava hazards
        initializeLava();

        // Add some initial spikes based on difficulty
        if (selectedDifficulty !== "easy") {
          // Add spikes at various positions
          const spikePositions = [450, 800, 1150];
          spikePositions.forEach((pos, idx) => {
            if (idx < (selectedDifficulty === "hard" ? 3 : 1)) {
              obstacles.push({
                x: pos,
                y: GROUND_LEVEL - 20,
                width: 24,
                height: 20,
                type: "spike",
              });
            }
          });
        }

        // Update UI to show current difficulty
        const difficultyLabels = {
          easy: "üå± Easy",
          medium: "‚ö° Medium",
          hard: "üî• Hard",
        };
        const diffDisplay = document.getElementById("current-difficulty");
        if (diffDisplay) {
          diffDisplay.textContent = difficultyLabels[selectedDifficulty];
        }
      }

      // Initialize Bill Blasters based on difficulty
      function initializeBillBlasters() {
        const difficulty = getDifficulty();
        billBlasters = [];
        bulletBills = [];

        // Add initial Bill Blasters based on difficulty
        const blasterPositions = [
          { x: 850, y: GROUND_LEVEL - 200 },
          { x: 1100, y: 200 },
        ];

        // Spawn initial blasters based on difficulty
        // Easy: No rockets at all
        // Medium: 0 initial blasters (reduced from 1)
        // Hard: 1 initial blaster (reduced from 2)
        const blasterCount =
          selectedDifficulty === "easy"
            ? 0
            : selectedDifficulty === "medium"
            ? 0
            : 1;

        for (let i = 0; i < blasterCount; i++) {
          const pos = blasterPositions[i];
          billBlasters.push({
            x: pos.x,
            y: pos.y,
            width: 48,
            height: 48,
            type: "blaster",
            shootTimer: 120 + Math.random() * 60,
            shootCooldown: selectedDifficulty === "hard" ? 180 : 300,
          });
        }
      }

      document.addEventListener("click", enableAudio);

      // Also handle the enable audio button specifically
      document.addEventListener("DOMContentLoaded", () => {
        const enableBtn = document.getElementById("enable-audio-btn");
        if (enableBtn) {
          enableBtn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent double triggering
            enableAudio();
          });
        }

        // Handle song selection
        document.querySelectorAll(".song-option").forEach((option) => {
          option.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent triggering enableAudio
            const index = parseInt(option.getAttribute("data-index"));
            selectSong(index);
          });
        });

        // Handle difficulty selection
        document.querySelectorAll(".difficulty-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent triggering enableAudio
            const difficulty = btn.getAttribute("data-difficulty");
            selectDifficulty(difficulty);
          });
        });

        // Initialize song selection display
        updateSongSelection();
        updateDifficultySelection();
      });

      // Function to select difficulty
      function selectDifficulty(difficulty) {
        if (difficultyConfig[difficulty]) {
          selectedDifficulty = difficulty;
          updateDifficultySelection();
        }
      }

      function updateDifficultySelection() {
        // Remove selected class from all options
        document.querySelectorAll(".difficulty-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });
        // Add selected class to current selection
        const selectedBtn = document.querySelector(
          `.difficulty-btn[data-difficulty="${selectedDifficulty}"]`
        );
        if (selectedBtn) {
          selectedBtn.classList.add("selected");
        }
        // Update description
        const infoEl = document.getElementById("difficulty-info");
        if (infoEl) {
          infoEl.textContent = getDifficulty().description;
        }
      }

      // Update timer
      function updateTimer() {
        if (!gameRunning) return;

        timeLeft--;
        document.getElementById("time").textContent = timeLeft;

        if (timeLeft <= 0) {
          gameOver();
        }
      }

      // Render everything
      function render() {
        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw background (doesn't move with camera)
        ctx.fillStyle = "#87ceeb";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw clouds (parallax effect - move slowly with camera)
        ctx.save();
        ctx.translate(-cameraX * 0.5, 0);
        drawClouds();
        ctx.restore();

        // Draw all world objects with camera offset
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw platforms
        platforms.forEach((platform) => {
          drawPlatform(platform);
        });

        // Draw enemies
        enemies.forEach((enemy) => {
          if (enemy.alive) {
            drawEnemy(enemy);
          }
        });

        // Draw power-ups
        powerUps.forEach((powerUp) => {
          drawPowerUp(powerUp);
        });

        // Draw lava hazards
        lavaHazards.forEach((lava) => {
          // Animated lava effect
          const time = Date.now() * 0.005;
          const alpha = 0.8 + Math.sin(time + lava.x * 0.01) * 0.2;

          // Main lava body
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = alpha;
          ctx.fillRect(lava.x, lava.y, lava.width, lava.height);

          // Lava highlights
          ctx.fillStyle = "#FFD700";
          ctx.globalAlpha = alpha * 0.6;
          ctx.fillRect(lava.x + 2, lava.y + 2, lava.width - 4, 4);

          // Lava bubbles
          ctx.fillStyle = "#FF6347";
          ctx.globalAlpha = alpha * 0.4;
          for (let i = 0; i < 5; i++) {
            const bubbleX = lava.x + 10 + i * 15 + Math.sin(time + i) * 3;
            const bubbleY = lava.y + 5 + Math.sin(time * 2 + i) * 2;
            ctx.fillRect(bubbleX, bubbleY, 3, 3);
          }

          ctx.globalAlpha = 1;
        });

        // Draw obstacles (spikes)
        obstacles.forEach((obstacle) => {
          if (obstacle.type === "spike") {
            drawSpike(obstacle);
          }
        });

        // Draw falling rocks
        fallingRocks.forEach((rock) => {
          drawFallingRock(rock);
        });

        // Draw Bill Blasters (cannons)
        billBlasters.forEach((blaster) => {
          drawBillBlaster(blaster);
        });

        // Draw Bullet Bills
        bulletBills.forEach((bullet) => {
          if (bullet.alive) {
            drawBulletBill(bullet);
          }
        });

        // Draw particles
        particles.forEach((particle) => {
          ctx.fillStyle = particle.color;
          ctx.globalAlpha = particle.life / 30;
          ctx.fillRect(
            particle.x - particle.size / 2,
            particle.y - particle.size / 2,
            particle.size,
            particle.size
          );
          ctx.globalAlpha = 1;
        });

        // Draw Mario
        drawMario();

        ctx.restore();

        // Update UI
        document.getElementById("score").textContent = score;

        // Show boss warning and health when boss area is near
        const boss = enemies.find((e) => e.type === "bowser" && e.alive);
        if (boss) {
          if (mario.x > 1000 && mario.x < boss.x - 100) {
            document.getElementById("boss-warning").style.display = "block";
          } else if (mario.x > boss.x - 200) {
            document.getElementById("boss-warning").style.display = "none";
            document.getElementById("boss-health").style.display = "block";
          }
        }
      }

      // Draw clouds
      function drawClouds() {
        ctx.fillStyle = "white";
        // Simple cloud shapes
        for (let i = 0; i < 5; i++) {
          const x = i * 200 + 50;
          const y = 100 + Math.sin(i) * 20;
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.arc(x + 25, y, 25, 0, Math.PI * 2);
          ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Draw platforms
      function drawPlatform(platform) {
        // Add flying effect for flying platforms
        if (platform.flying) {
          // Add a subtle glow/shadow effect
          ctx.save();
          ctx.shadowColor = "rgba(255, 255, 100, 0.5)";
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 2;
        }

        switch (platform.type) {
          case "ground":
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            // Grass on top
            ctx.fillStyle = "#228B22";
            ctx.fillRect(platform.x, platform.y, platform.width, 10);
            break;
          case "platform":
            ctx.fillStyle = "#DEB887";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            break;
          case "brick":
            ctx.fillStyle = platform.breakable ? "#CD853F" : "#696969";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            // Brick pattern
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            break;
          case "question":
            ctx.fillStyle = platform.used ? "#D2B48C" : "#FFD700";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            if (!platform.used) {
              ctx.fillStyle = "#000";
              ctx.font = "20px Arial";
              ctx.textAlign = "center";
              ctx.fillText(
                "?",
                platform.x + platform.width / 2,
                platform.y + platform.height / 2 + 7
              );
            }
            break;
          case "pipe":
            ctx.fillStyle = "#228B22";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            ctx.fillStyle = "#000";
            ctx.fillRect(
              platform.x + 5,
              platform.y,
              platform.width - 10,
              platform.height
            );
            break;
        }

        // Restore context for flying platforms
        if (platform.flying) {
          ctx.restore();
        }
      }

      // Draw Mario
      function drawMario() {
        // Set Mario's size based on power level
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Overalls (blue)
        ctx.fillStyle = "#0000FF";
        ctx.fillRect(
          mario.x + 6,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          20,
          baseHeight - (mario.powerLevel === 0 ? 16 : 24)
        );

        // Shirt (red)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 6, mario.y + 8, 20, baseHeight - 24);

        // Skin (peach)
        ctx.fillStyle = "#FFB366";
        ctx.fillRect(mario.x + 8, mario.y + 4, 16, 12);

        // Hat (red with logo)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 6, mario.y - 2, 20, 8);
        // Hat logo (white M)
        ctx.fillStyle = "#FFF";
        ctx.font = "bold 6px Arial";
        ctx.fillText("M", mario.x + 14, mario.y + 4);

        // Eyes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 10, mario.y + 6, 3, 3);
        ctx.fillRect(mario.x + 19, mario.y + 6, 3, 3);

        // Mustache (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 12, mario.y + 12, 8, 2);

        // Buttons on overalls (yellow)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 20 : 28),
          4,
          4
        );
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 26 : 36),
          4,
          4
        );

        // Gloves (white)
        ctx.fillStyle = "#FFF";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );

        // Shoes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 20, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Mario - add flames
          ctx.fillStyle = "#FF4500";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        // Update Mario's actual size for collision detection
        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw enemies
      function drawEnemy(enemy) {
        if (enemy.type === "goomba") {
          // Goomba body - brown mushroom shape
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(enemy.x + 2, enemy.y + 8, 28, 24);

          // Goomba cap - slightly darker brown
          ctx.fillStyle = "#654321";
          ctx.fillRect(enemy.x, enemy.y, 32, 12);

          // White spots on cap (classic Goomba pattern)
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(enemy.x + 4, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 12, enemy.y + 4, 4, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 24, enemy.y + 6, 4, 4);

          // Goomba eyes - simple black dots
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 8, enemy.y + 6, 3, 3);
          ctx.fillRect(enemy.x + 21, enemy.y + 6, 3, 3);

          // Goomba feet - simple brown rectangles
          ctx.fillStyle = "#654321";
          ctx.fillRect(enemy.x + 6, enemy.y + 28, 6, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 28, 6, 4);
        } else if (enemy.type === "koopa") {
          // Koopa shell - green with darker green pattern
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x, enemy.y + 16, 32, 16);

          // Shell pattern - darker green sections
          ctx.fillStyle = "#006400";
          ctx.fillRect(enemy.x + 4, enemy.y + 18, 24, 4);
          ctx.fillRect(enemy.x + 8, enemy.y + 22, 16, 4);
          ctx.fillRect(enemy.x + 12, enemy.y + 26, 8, 4);

          // Koopa head - green with simple eyes
          ctx.fillStyle = "#32CD32";
          ctx.fillRect(enemy.x + 8, enemy.y, 16, 16);

          // Koopa eyes - simple black dots
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 10, enemy.y + 4, 2, 2);
          ctx.fillRect(enemy.x + 20, enemy.y + 4, 2, 2);

          // Simple mouth line
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(enemy.x + 12, enemy.y + 10);
          ctx.lineTo(enemy.x + 20, enemy.y + 10);
          ctx.stroke();

          // Koopa legs - simple green rectangles
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x + 6, enemy.y + 14, 6, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 14, 6, 4);
        } else if (enemy.type === "dragon") {
          // Dragon - flying enemy
          // Body - dark green
          ctx.fillStyle = "#006400";
          ctx.fillRect(enemy.x + 8, enemy.y + 8, 32, 16);

          // Wings - lighter green, flapping effect
          const wingOffset = Math.sin(Date.now() * 0.01) * 3;
          ctx.fillStyle = "#32CD32";
          // Left wing
          ctx.fillRect(enemy.x, enemy.y + 4 + wingOffset, 12, 8);
          // Right wing
          ctx.fillRect(enemy.x + 36, enemy.y + 4 - wingOffset, 12, 8);

          // Head - darker green
          ctx.fillStyle = "#004400";
          ctx.fillRect(enemy.x + 16, enemy.y, 16, 12);

          // Eyes - glowing yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 18, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 26, enemy.y + 2, 4, 4);
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 19, enemy.y + 3, 2, 2);
          ctx.fillRect(enemy.x + 27, enemy.y + 3, 2, 2);

          // Horns - red
          ctx.fillStyle = "#FF0000";
          ctx.fillRect(enemy.x + 14, enemy.y - 2, 4, 6);
          ctx.fillRect(enemy.x + 30, enemy.y - 2, 4, 6);

          // Tail - green with spikes
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x + 40, enemy.y + 12, 8, 4);
          // Tail spikes
          ctx.fillStyle = "#FF0000";
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(enemy.x + 42 + i * 2, enemy.y + 8, 2, 4);
          }

          // Fire breath (occasional)
          if (enemy.fireTimer > 0) {
            ctx.fillStyle = "#FF4500";
            ctx.fillRect(enemy.x + 44, enemy.y + 10, 8, 2);
            ctx.fillStyle = "#FFD700";
            ctx.fillRect(enemy.x + 46, enemy.y + 8, 4, 2);
          }
        } else if (enemy.type === "bowser") {
          // Bowser - large boss enemy
          // Body - dark red
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 8, enemy.y + 24, 48, 40);

          // Shell/back spikes - dark red with spikes
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 12, enemy.y + 16, 40, 16);
          // Spikes
          ctx.fillStyle = "#DC143C";
          for (let i = 0; i < 5; i++) {
            ctx.fillRect(enemy.x + 16 + i * 8, enemy.y + 12, 4, 8);
          }

          // Head - dark red with horns
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 16, enemy.y, 32, 24);

          // Horns - yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 12, enemy.y - 4, 6, 8);
          ctx.fillRect(enemy.x + 46, enemy.y - 4, 6, 8);

          // Eyes - glowing yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 20, enemy.y + 6, 6, 6);
          ctx.fillRect(enemy.x + 38, enemy.y + 6, 6, 6);
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 22, enemy.y + 8, 2, 2);
          ctx.fillRect(enemy.x + 40, enemy.y + 8, 2, 2);

          // Angry eyebrows
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 18, enemy.y + 2, 10, 2);
          ctx.fillRect(enemy.x + 36, enemy.y + 2, 10, 2);

          // Mouth/Fangs - white fangs
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(enemy.x + 24, enemy.y + 16, 4, 6);
          ctx.fillRect(enemy.x + 36, enemy.y + 16, 4, 6);

          // Arms - dark red
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x, enemy.y + 20, 12, 8);
          ctx.fillRect(enemy.x + 52, enemy.y + 20, 12, 8);

          // Legs - dark red with claws
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 12, enemy.y + 56, 12, 8);
          ctx.fillRect(enemy.x + 40, enemy.y + 56, 12, 8);

          // Claws - black
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 10, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 18, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 38, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 46, enemy.y + 60, 4, 4);
        }
      }

      // Draw power-ups
      function drawPowerUp(powerUp) {
        if (powerUp.type === "mushroom") {
          ctx.fillStyle = "#FF69B4";
          ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
          // Spots
          ctx.fillStyle = "#FFF";
          ctx.fillRect(powerUp.x + 8, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 16, 4, 4);
        } else if (powerUp.type === "fireflower") {
          ctx.fillStyle = "#FF0000";
          ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
          // Center
          ctx.fillStyle = "#FFFF00";
          ctx.fillRect(powerUp.x + 12, powerUp.y + 12, 8, 8);
          // Petals
          ctx.fillStyle = "#FFA500";
          ctx.fillRect(powerUp.x + 8, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 8, powerUp.y + 20, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 20, 4, 4);
        }
      }

      // Draw spike obstacle
      function drawSpike(spike) {
        const x = spike.x;
        const y = spike.y;
        const w = spike.width;
        const h = spike.height;

        // Draw triangular spike
        ctx.fillStyle = "#808080"; // Gray metal color
        ctx.beginPath();
        ctx.moveTo(x, y + h); // Bottom left
        ctx.lineTo(x + w / 2, y); // Top center (point)
        ctx.lineTo(x + w, y + h); // Bottom right
        ctx.closePath();
        ctx.fill();

        // Add highlight
        ctx.fillStyle = "#A0A0A0";
        ctx.beginPath();
        ctx.moveTo(x + 3, y + h);
        ctx.lineTo(x + w / 2, y + 3);
        ctx.lineTo(x + w / 2, y + h);
        ctx.closePath();
        ctx.fill();

        // Add dark edge
        ctx.strokeStyle = "#404040";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + h);
        ctx.lineTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h);
        ctx.stroke();

        // Base
        ctx.fillStyle = "#505050";
        ctx.fillRect(x, y + h - 4, w, 4);
      }

      // Draw falling rock
      function drawFallingRock(rock) {
        ctx.save();
        ctx.translate(rock.x + rock.width / 2, rock.y + rock.height / 2);
        ctx.rotate(rock.rotation);

        // Main rock body - irregular shape
        ctx.fillStyle = "#8B4513"; // Brown
        ctx.fillRect(
          -rock.width / 2,
          -rock.height / 2,
          rock.width,
          rock.height
        );

        // Add texture/cracks
        ctx.fillStyle = "#654321";
        ctx.fillRect(
          -rock.width / 4,
          -rock.height / 3,
          rock.width / 4,
          rock.height / 3
        );
        ctx.fillRect(
          rock.width / 6,
          rock.height / 6,
          rock.width / 4,
          rock.height / 4
        );

        // Highlight
        ctx.fillStyle = "#A0522D";
        ctx.fillRect(
          -rock.width / 3,
          -rock.height / 2,
          rock.width / 3,
          rock.height / 4
        );

        // Outline
        ctx.strokeStyle = "#3E2723";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          -rock.width / 2,
          -rock.height / 2,
          rock.width,
          rock.height
        );

        ctx.restore();

        // Warning indicator above rock
        if (rock.y < 50) {
          ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.fillText("‚ö†", rock.x + rock.width / 2, 30);
        }
      }

      // Draw Bill Blaster (cannon)
      function drawBillBlaster(blaster) {
        // Main cannon body - dark gray/black
        ctx.fillStyle = "#2F2F2F";
        ctx.fillRect(blaster.x, blaster.y, blaster.width, blaster.height);

        // Cannon barrel - lighter gray
        ctx.fillStyle = "#4A4A4A";
        ctx.fillRect(
          blaster.x + 8,
          blaster.y,
          blaster.width - 16,
          blaster.height / 2
        );

        // Cannon opening - black circle
        ctx.fillStyle = "#000000";
        const openingY = blaster.y + blaster.height / 4;
        ctx.fillRect(
          blaster.x + blaster.width / 4,
          openingY,
          blaster.width / 2,
          blaster.height / 4
        );

        // Highlight on cannon
        ctx.fillStyle = "#6A6A6A";
        ctx.fillRect(blaster.x + 4, blaster.y + 4, 8, blaster.height / 3);

        // Base/stand
        ctx.fillStyle = "#1F1F1F";
        ctx.fillRect(
          blaster.x,
          blaster.y + blaster.height - 8,
          blaster.width,
          8
        );

        // Metallic rivets
        ctx.fillStyle = "#808080";
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(
            blaster.x + 10 + i * 12,
            blaster.y + blaster.height / 2,
            4,
            4
          );
        }

        // Skull icon (classic Bill Blaster design)
        ctx.fillStyle = "#FFFFFF";
        const skullX = blaster.x + blaster.width / 2 - 6;
        const skullY = blaster.y + blaster.height - 20;
        // Simple skull shape
        ctx.fillRect(skullX, skullY, 12, 8);
        // Eyes
        ctx.fillStyle = "#000000";
        ctx.fillRect(skullX + 2, skullY + 2, 3, 3);
        ctx.fillRect(skullX + 7, skullY + 2, 3, 3);
      }

      // Draw Bullet Bill (rocket)
      function drawBulletBill(bullet) {
        const facingLeft = bullet.velocityX < 0;

        // Main body - black bullet shape
        ctx.fillStyle = "#000000";
        if (facingLeft) {
          // Bullet facing left
          ctx.fillRect(bullet.x + 8, bullet.y + 4, 24, 24);
          // Pointed nose
          ctx.fillRect(bullet.x, bullet.y + 12, 8, 8);
        } else {
          // Bullet facing right
          ctx.fillRect(bullet.x, bullet.y + 4, 24, 24);
          // Pointed nose
          ctx.fillRect(bullet.x + 24, bullet.y + 12, 8, 8);
        }

        // Arms (extending from sides)
        ctx.fillStyle = "#1A1A1A";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 12, bullet.y, 8, 4); // Top arm
          ctx.fillRect(bullet.x + 12, bullet.y + 28, 8, 4); // Bottom arm
        } else {
          ctx.fillRect(bullet.x + 12, bullet.y, 8, 4); // Top arm
          ctx.fillRect(bullet.x + 12, bullet.y + 28, 8, 4); // Bottom arm
        }

        // Eyes - angry white eyes
        ctx.fillStyle = "#FFFFFF";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 10, bullet.y + 10, 6, 4);
          ctx.fillRect(bullet.x + 10, bullet.y + 18, 6, 4);
        } else {
          ctx.fillRect(bullet.x + 16, bullet.y + 10, 6, 4);
          ctx.fillRect(bullet.x + 16, bullet.y + 18, 6, 4);
        }

        // Pupils - black dots
        ctx.fillStyle = "#000000";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 11, bullet.y + 11, 2, 2);
          ctx.fillRect(bullet.x + 11, bullet.y + 19, 2, 2);
        } else {
          ctx.fillRect(bullet.x + 19, bullet.y + 11, 2, 2);
          ctx.fillRect(bullet.x + 19, bullet.y + 19, 2, 2);
        }

        // Mouth/grimace
        ctx.fillStyle = "#FFFFFF";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 8, bullet.y + 14, 6, 4);
        } else {
          ctx.fillRect(bullet.x + 18, bullet.y + 14, 6, 4);
        }

        // Exhaust flame effect at back
        const time = Date.now() * 0.02;
        const flameSize = 4 + Math.sin(time) * 2;
        ctx.fillStyle = "#FF4500";
        if (facingLeft) {
          ctx.fillRect(
            bullet.x + 28,
            bullet.y + 14 - flameSize / 2,
            flameSize,
            flameSize
          );
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(
            bullet.x + 30,
            bullet.y + 15 - flameSize / 4,
            flameSize / 2,
            flameSize / 2
          );
        } else {
          ctx.fillRect(
            bullet.x - flameSize,
            bullet.y + 14 - flameSize / 2,
            flameSize,
            flameSize
          );
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(
            bullet.x - flameSize / 2,
            bullet.y + 15 - flameSize / 4,
            flameSize / 2,
            flameSize / 2
          );
        }
      }

      // Start the game when page loads
      window.onload = init;
    </script>
  </body>
</html>
