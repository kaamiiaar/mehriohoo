<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Super Mario Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #5c94fc;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      #game-container {
        position: relative;
        width: min(90vw, 800px);
        height: min(75vh, 600px);
        margin: 20px auto;
        border: 3px solid #000;
        background: linear-gradient(to bottom, #5c94fc 0%, #87ceeb 100%);
        max-width: 100%;
      }

      #game-canvas {
        display: block;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 100%);
        max-width: 100%;
        max-height: 100%;
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
        z-index: 1000;
      }

      #game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        display: none;
        z-index: 1000;
        min-width: 250px;
        max-width: 90vw;
      }

      /* Audio enable overlay */
      #audio-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1500;
        cursor: pointer;
      }

      #audio-message {
        background-color: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        font-size: 18px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        max-width: 600px;
        max-height: 90vh;
        overflow-x: hidden;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }

      #audio-message h2 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #ff6b35;
      }

      .section-label {
        font-weight: bold;
        margin-bottom: 10px;
        margin-top: 10px;
        color: #333;
        font-size: 16px;
      }

      #audio-message p {
        margin-bottom: 20px;
      }

      /* Custom scrollbar styling */
      #audio-message::-webkit-scrollbar,
      .song-selection::-webkit-scrollbar,
      .character-options::-webkit-scrollbar {
        width: 8px;
        height: 6px;
      }

      #audio-message::-webkit-scrollbar-track,
      .song-selection::-webkit-scrollbar-track,
      .character-options::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
      }

      #audio-message::-webkit-scrollbar-thumb,
      .song-selection::-webkit-scrollbar-thumb,
      .character-options::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }

      #audio-message::-webkit-scrollbar-thumb:hover,
      .song-selection::-webkit-scrollbar-thumb:hover,
      .character-options::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      .song-selection {
        margin: 20px 0;
        text-align: left;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 14px;
        max-height: 40vh;
        overflow-y: auto;
        padding: 8px;
      }

      .song-option {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 18px 14px;
        background-color: #f8f9fa;
        border: 2px solid #e9ecef;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
        text-align: center;
        min-height: 90px;
      }

      .song-option:hover {
        background-color: #e3f2fd;
        border-color: #2196f3;
      }

      .song-option.selected {
        background-color: #2196f3;
        color: white;
        border-color: #1976d2;
      }

      .song-option.selected:hover {
        background-color: #1976d2;
      }

      .song-info {
        flex-grow: 1;
        width: 100%;
      }

      .song-name {
        font-weight: bold;
        font-size: 18px;
        margin-bottom: 6px;
      }

      .song-description {
        font-size: 13px;
        opacity: 0.8;
        line-height: 1.4;
      }

      .song-option.selected .song-description {
        opacity: 0.9;
      }

      /* Difficulty Selection */
      .difficulty-selection {
        margin: 15px 0;
      }

      .difficulty-label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
        font-size: 16px;
      }

      .difficulty-options {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .difficulty-btn {
        padding: 12px 24px;
        border: 3px solid #ddd;
        border-radius: 12px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s ease;
        background: linear-gradient(to bottom, #fff 0%, #f0f0f0 100%);
      }

      .difficulty-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .difficulty-btn.easy {
        border-color: #4caf50;
        color: #4caf50;
      }

      .difficulty-btn.easy.selected {
        background: linear-gradient(to bottom, #66bb6a 0%, #4caf50 100%);
        color: white;
        border-color: #388e3c;
      }

      .difficulty-btn.medium {
        border-color: #ff9800;
        color: #ff9800;
      }

      .difficulty-btn.medium.selected {
        background: linear-gradient(to bottom, #ffb74d 0%, #ff9800 100%);
        color: white;
        border-color: #f57c00;
      }

      .difficulty-btn.hard {
        border-color: #f44336;
        color: #f44336;
      }

      .difficulty-btn.hard.selected {
        background: linear-gradient(to bottom, #ef5350 0%, #f44336 100%);
        color: white;
        border-color: #d32f2f;
      }

      .difficulty-info {
        font-size: 12px;
        color: #666;
        margin-top: 8px;
      }

      /* Character Selection */
      .character-selection {
        margin: 15px 0;
      }

      .character-label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
        font-size: 16px;
      }

      .character-options {
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding: 5px 0;
      }

      .character-btn {
        padding: 10px 8px;
        border: 3px solid #ddd;
        border-radius: 12px;
        cursor: pointer;
        font-size: 13px;
        font-weight: bold;
        transition: all 0.3s ease;
        background: linear-gradient(to bottom, #fff 0%, #f0f0f0 100%);
        min-width: 85px;
        max-width: 85px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        flex-shrink: 0;
      }

      .character-preview {
        width: 48px;
        height: 48px;
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        flex-shrink: 0;
      }

      .character-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .character-btn.mario {
        border-color: #ff0000;
        color: #ff0000;
      }

      .character-btn.mario.selected {
        background: linear-gradient(to bottom, #ff6b6b 0%, #ff0000 100%);
        color: white;
        border-color: #cc0000;
      }

      .character-btn.luigi {
        border-color: #00cc00;
        color: #00cc00;
      }

      .character-btn.luigi.selected {
        background: linear-gradient(to bottom, #66ff66 0%, #00cc00 100%);
        color: white;
        border-color: #009900;
      }

      .character-btn.peach {
        border-color: #ff69b4;
        color: #ff69b4;
      }

      .character-btn.peach.selected {
        background: linear-gradient(to bottom, #ffb3d9 0%, #ff69b4 100%);
        color: white;
        border-color: #ff1493;
      }

      .character-btn.toad {
        border-color: #9370db;
        color: #9370db;
      }

      .character-btn.toad.selected {
        background: linear-gradient(to bottom, #ba9ddb 0%, #9370db 100%);
        color: white;
        border-color: #7b68ee;
      }

      .character-btn.bowser {
        border-color: #ff8c00;
        color: #ff8c00;
      }

      .character-btn.bowser.selected {
        background: linear-gradient(to bottom, #ffb347 0%, #ff8c00 100%);
        color: white;
        border-color: #ff6600;
      }

      #enable-audio-btn {
        background-color: #ff6b35;
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease;
        margin-top: 20px;
        width: 100%;
        flex-shrink: 0;
      }

      #enable-audio-btn:hover {
        background-color: #ff5722;
      }

      /* Touch Controls for Mobile/iPad */
      #touch-controls {
        position: fixed;
        bottom: 40px;
        left: 0;
        right: 0;
        width: 100%;
        display: none; /* Hidden by default, shown when game starts */
        justify-content: space-between;
        padding: 0 30px;
        z-index: 2000;
        pointer-events: none;
      }

      .touch-button {
        width: 90px;
        height: 90px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.8);
        border: 4px solid #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        color: white;
        font-size: 28px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        pointer-events: auto;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        transition: all 0.1s ease;
        position: relative;
      }

      .touch-button:active {
        background-color: rgba(255, 200, 50, 0.9);
        color: black;
        transform: scale(0.92);
        border-color: #ffcc00;
      }

      .left-controls {
        display: flex;
        gap: 15px;
        pointer-events: none;
      }

      #jump-button {
        width: 110px;
        height: 110px;
        font-size: 22px;
        border-radius: 20px;
      }

      /* Mobile responsiveness */
      @media (max-width: 767px) {
        #game-container {
          width: 95vw;
          height: 70vh;
          margin: 10px auto;
          border-width: 2px;
        }

        #ui {
          font-size: 14px;
          top: 5px;
          left: 5px;
        }

        #ui > div {
          margin-bottom: 2px;
        }

        #difficulty-display {
          font-size: 11px !important;
        }

        #boss-warning {
          font-size: 14px;
        }

        #victory-message {
          font-size: 16px;
        }

        #game-over {
          padding: 15px;
          min-width: 200px;
        }

        #game-over h2 {
          font-size: 24px;
          margin-bottom: 10px;
        }

        #game-over p {
          font-size: 16px;
          margin-bottom: 15px;
        }

        #game-over button {
          padding: 12px 24px;
          font-size: 16px;
        }

        .touch-button {
          width: 100px;
          height: 100px;
          font-size: 32px;
        }

        #jump-button {
          width: 120px;
          height: 120px;
          font-size: 24px;
        }

        #touch-controls {
          bottom: 20px;
          padding: 0 20px;
        }

        #audio-message {
          max-width: 95vw;
          max-height: 95vh;
          padding: 20px 15px;
        }

        .song-selection {
          grid-template-columns: 1fr;
          max-height: 35vh;
        }

        .character-options {
          gap: 6px;
          justify-content: flex-start;
        }

        .character-btn {
          min-width: 65px;
          max-width: 65px;
          padding: 8px 4px;
          font-size: 11px;
          gap: 4px;
        }

        .character-preview {
          width: 40px;
          height: 40px;
        }

        .difficulty-options {
          gap: 8px;
        }

        .difficulty-btn {
          padding: 10px 16px;
          font-size: 12px;
        }
      }

      /* Tablet responsiveness */
      @media (max-width: 1024px) and (min-width: 768px) {
        #game-container {
          width: min(85vw, 800px);
          height: min(70vh, 600px);
        }

        #ui {
          font-size: 15px;
        }
      }

      /* Small desktop screens */
      @media (max-width: 1200px) and (min-width: 1025px) {
        #game-container {
          width: min(80vw, 800px);
          height: min(65vh, 600px);
        }
      }

      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
      }

      button:hover {
        background-color: #45a049;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="game-canvas"></canvas>
      <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Time: <span id="time">400</span></div>
        <div id="difficulty-display" style="font-size: 12px; opacity: 0.8">
          Difficulty: <span id="current-difficulty">Easy</span>
        </div>
        <div
          id="boss-warning"
          style="display: none; color: red; font-weight: bold"
        >
          ‚ö†Ô∏è BOWSER'S CASTLE AHEAD! ‚ö†Ô∏è
        </div>
        <div id="boss-health" style="display: none">
          Boss Health: <span id="boss-health-value">5</span>
        </div>
        <div
          id="victory-message"
          style="display: none; color: gold; font-weight: bold; font-size: 18px"
        >
          üéâ VICTORY! You defeated Bowser! üéâ<br />
          You completed the level!
        </div>
      </div>
      <div id="game-over">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="restartGame()">Play Again</button>
      </div>

      <!-- Audio Enable Overlay -->
      <div id="audio-overlay">
        <div id="audio-message">
          <h2>üéµ Choose Your Soundtrack</h2>

          <div class="section-label">üé∂ Background Music</div>
          <div class="song-selection">
            <div class="song-option selected" data-index="0">
              <div class="song-info">
                <div class="song-name">üé≠ Game of Thrones</div>
                <div class="song-description">Epic orchestral soundtrack</div>
              </div>
            </div>

            <div class="song-option" data-index="1">
              <div class="song-info">
                <div class="song-name">üçÑ Super Mario</div>
                <div class="song-description">Classic 8-bit adventure</div>
              </div>
            </div>

            <div class="song-option" data-index="2">
              <div class="song-info">
                <div class="song-name">üïµÔ∏è James Bond</div>
                <div class="song-description">Classic spy thriller theme</div>
              </div>
            </div>

            <div class="song-option" data-index="3">
              <div class="song-info">
                <div class="song-name">üé¨ Mission Impossible</div>
                <div class="song-description">High-stakes action music</div>
              </div>
            </div>
          </div>

          <div class="difficulty-selection">
            <div class="difficulty-label">‚öîÔ∏è Select Difficulty</div>
            <div class="difficulty-options">
              <div class="difficulty-btn easy selected" data-difficulty="easy">
                üå± Easy
              </div>
              <div class="difficulty-btn medium" data-difficulty="medium">
                ‚ö° Medium
              </div>
              <div class="difficulty-btn hard" data-difficulty="hard">
                üî• Hard
              </div>
            </div>
            <div class="difficulty-info" id="difficulty-info">
              Fewer enemies, slower speed, less obstacles
            </div>
          </div>

          <div class="character-selection">
            <div class="character-label">üéÆ Select Character</div>
            <div class="character-options">
              <div class="character-btn mario selected" data-character="mario">
                <canvas
                  class="character-preview"
                  id="preview-mario"
                  width="48"
                  height="48"
                ></canvas>
                Mario
              </div>
              <div class="character-btn luigi" data-character="luigi">
                <canvas
                  class="character-preview"
                  id="preview-luigi"
                  width="48"
                  height="48"
                ></canvas>
                Luigi
              </div>
              <div class="character-btn peach" data-character="peach">
                <canvas
                  class="character-preview"
                  id="preview-peach"
                  width="48"
                  height="48"
                ></canvas>
                Peach
              </div>
              <div class="character-btn toad" data-character="toad">
                <canvas
                  class="character-preview"
                  id="preview-toad"
                  width="48"
                  height="48"
                ></canvas>
                Toad
              </div>
              <div class="character-btn bowser" data-character="bowser">
                <canvas
                  class="character-preview"
                  id="preview-bowser"
                  width="48"
                  height="48"
                ></canvas>
                Bowser
              </div>
            </div>
          </div>

          <button id="enable-audio-btn">üé∂ Start Game with Sound</button>
        </div>
      </div>

      <!-- Touch Controls for Mobile/iPad -->
      <div id="touch-controls">
        <div class="left-controls">
          <div id="left-button" class="touch-button">‚Üê</div>
          <div id="right-button" class="touch-button">‚Üí</div>
        </div>
        <div id="jump-button" class="touch-button">JUMP</div>
      </div>
    </div>

    <script>
      // Audio system
      let audioContext;
      let backgroundMusic;
      let currentAudio = null;

      // Available soundtracks
      const soundtracks = [
        {
          name: "Game of Thrones",
          file: "game-of-thrones-soundtrack.mp3",
          description: "Epic orchestral soundtrack",
        },
        {
          name: "Super Mario",
          file: "super-mario-soundtrack.mp3",
          description: "Classic 8-bit adventure",
        },
        {
          name: "James Bond",
          file: "james-bond-soundtrack.mp3",
          description: "Classic spy thriller theme",
        },
        {
          name: "Mission Impossible",
          file: "mission-impossible-soundtrack.mp3",
          description: "High-stakes action music",
        },
      ];

      let selectedSongIndex = 0; // Default to first song
      let selectedDifficulty = "easy"; // Default difficulty
      let selectedCharacter = "mario"; // Default character

      // Difficulty configurations
      const difficultyConfig = {
        easy: {
          enemySpawnRate: 0.6, // Fewer enemies
          enemySpeedMultiplier: 0.7, // Slower enemies
          dragonChanceBase: 0.05, // Less dragons
          dragonChanceMax: 0.25,
          spikeSpawnRate: 0.1, // Few spikes
          rockSpawnRate: 0.05, // Rare falling rocks
          lavaWidth: 48, // Smaller lava
          spawnGapBase: 350, // More space between enemies
          spawnGapReduction: 80,
          initialEnemyCount: 3,
          description: "Fewer enemies, slower speed, less obstacles",
        },
        medium: {
          enemySpawnRate: 1.0,
          enemySpeedMultiplier: 1.0,
          dragonChanceBase: 0.1,
          dragonChanceMax: 0.4,
          spikeSpawnRate: 0.2,
          rockSpawnRate: 0.1,
          lavaWidth: 64,
          spawnGapBase: 250,
          spawnGapReduction: 100,
          initialEnemyCount: 6,
          description: "Balanced challenge with moderate obstacles",
        },
        hard: {
          enemySpawnRate: 1.5, // More enemies
          enemySpeedMultiplier: 1.4, // Faster enemies
          dragonChanceBase: 0.2, // More dragons
          dragonChanceMax: 0.6,
          spikeSpawnRate: 0.35, // Many spikes
          rockSpawnRate: 0.2, // Frequent falling rocks
          lavaWidth: 96, // Larger lava
          spawnGapBase: 150, // Enemies close together
          spawnGapReduction: 50,
          initialEnemyCount: 10,
          description: "Many enemies, fast pace, dangerous obstacles",
        },
      };

      // Get current difficulty settings
      function getDifficulty() {
        return difficultyConfig[selectedDifficulty];
      }

      // Initialize audio
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          // Initialize all audio files
          soundtracks.forEach((track) => {
            track.audio = new Audio(track.file);
            track.audio.loop = true;
            track.audio.volume = 0.3;
          });
        } catch (e) {
          console.log("Web Audio API not supported");
        }
      }

      // Play a simple beep sound
      function playBeep(frequency, duration, type = "square") {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + duration
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      }

      // Play Mario jump sound
      function playJumpSound() {
        playBeep(523, 0.1); // C5
        setTimeout(() => playBeep(659, 0.1), 50); // E5
      }

      // Play coin/power-up collection sound
      function playCoinSound() {
        playBeep(800, 0.1);
        setTimeout(() => playBeep(1000, 0.1), 50);
        setTimeout(() => playBeep(1200, 0.1), 100);
      }

      // Play enemy defeat sound
      function playEnemyDefeatSound() {
        playBeep(200, 0.2);
        setTimeout(() => playBeep(150, 0.2), 100);
      }

      // Play brick break sound
      function playBreakSound() {
        playBeep(100, 0.1, "sawtooth");
        setTimeout(() => playBeep(80, 0.1, "sawtooth"), 50);
        setTimeout(() => playBeep(60, 0.2, "sawtooth"), 100);
      }

      // Play power-up sound
      function playPowerUpSound() {
        playBeep(600, 0.1);
        setTimeout(() => playBeep(700, 0.1), 50);
        setTimeout(() => playBeep(800, 0.1), 100);
        setTimeout(() => playBeep(900, 0.2), 150);
      }

      // Play game over sound
      function playGameOverSound() {
        // Descending notes
        const notes = [400, 350, 300, 250, 200, 150];
        notes.forEach((freq, index) => {
          setTimeout(() => playBeep(freq, 0.3), index * 100);
        });
      }

      // Play boss entrance sound
      function playBossEntranceSound() {
        playBeep(100, 0.3, "sawtooth");
        setTimeout(() => playBeep(150, 0.3, "sawtooth"), 100);
        setTimeout(() => playBeep(200, 0.5, "sawtooth"), 200);
      }

      // Play spike hit sound
      function playSpikeSound() {
        playBeep(150, 0.15, "sawtooth");
        setTimeout(() => playBeep(100, 0.2, "sawtooth"), 50);
      }

      // Play falling rock warning sound
      function playRockWarningSound() {
        playBeep(300, 0.1);
        setTimeout(() => playBeep(350, 0.1), 100);
      }

      // Background music - plays selected soundtrack
      function startBackgroundMusic() {
        const selectedTrack = soundtracks[selectedSongIndex];
        if (selectedTrack && selectedTrack.audio) {
          // Stop any currently playing audio
          stopBackgroundMusic();
          // Play the selected soundtrack
          currentAudio = selectedTrack.audio;
          currentAudio.play().catch((e) => {
            console.log("Audio play failed:", e);
            // Fallback to generated music if MP3 fails to load
            fallbackToGeneratedMusic();
          });
        } else {
          // Fallback to generated music
          fallbackToGeneratedMusic();
        }
      }

      function fallbackToGeneratedMusic() {
        if (audioContext && !backgroundMusic) {
          let noteIndex = 0;
          const melody = [
            330, 330, 330, 262, 330, 392, 196, 262, 196, 165, 220, 247, 233,
            220, 196, 330, 349, 392, 330, 262, 294, 247, 262, 196, 165, 220,
            247, 233, 220, 196, 330, 392, 440, 392, 330, 262, 294, 247, 349,
            330, 262, 294, 247, 196, 165, 220, 247,
          ];

          backgroundMusic = setInterval(() => {
            if (noteIndex < melody.length) {
              playBeep(melody[noteIndex], 0.15, "triangle");
              noteIndex++;
            } else {
              noteIndex = 0;
            }
          }, 200);
        }
      }

      function stopBackgroundMusic() {
        // Stop currently playing soundtrack
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio = null;
        }
        // Stop generated music fallback
        if (backgroundMusic) {
          clearInterval(backgroundMusic);
          backgroundMusic = null;
        }
      }

      // Function to select a song
      function selectSong(index) {
        if (index >= 0 && index < soundtracks.length) {
          selectedSongIndex = index;
          // Update visual selection
          updateSongSelection();
        }
      }

      function updateSongSelection() {
        // Remove selected class from all options
        document.querySelectorAll(".song-option").forEach((option) => {
          option.classList.remove("selected");
        });
        // Add selected class to current selection
        const selectedOption = document.querySelector(
          `.song-option[data-index="${selectedSongIndex}"]`
        );
        if (selectedOption) {
          selectedOption.classList.add("selected");
        }
      }

      // Game constants - will be set dynamically in init()
      let CANVAS_WIDTH = 800;
      let CANVAS_HEIGHT = 600;
      const GRAVITY = 0.5;
      const JUMP_FORCE = -12;
      const MOVE_SPEED = 5;
      let GROUND_LEVEL = 500; // Will be updated in init() based on canvas height

      // Game variables
      let canvas, ctx;
      let gameRunning = true;
      let score = 0;
      let lives = 3;
      let timeLeft = 400;
      let gameLoop;

      // Castle interior system
      let insideCastle = false;
      let castleEntranceZone = null; // Will be set in init
      let showEnterPrompt = false;

      // Camera system
      let cameraX = 0;

      // Player (Mario)
      let mario = {
        x: 50, // Safe starting position
        y: GROUND_LEVEL - 32,
        width: 32,
        height: 32,
        velocityX: 0,
        velocityY: 0,
        onGround: false,
        facing: "right",
        powerLevel: 0, // 0: small, 1: big, 2: fire
        animationFrame: 0,
        animationTimer: 0,
        punchCooldown: 0,
      };

      // Platforms and level elements
      let platforms = [
        // Ground
        {
          x: 0,
          y: GROUND_LEVEL,
          width: CANVAS_WIDTH,
          height: 100,
          type: "ground",
        },

        // Platforms
        { x: 300, y: 400, width: 150, height: 20, type: "platform" },
        { x: 500, y: 350, width: 100, height: 20, type: "platform" },
        { x: 650, y: 300, width: 100, height: 20, type: "platform" },
        // Challenging platforms for level progression
        { x: 850, y: 250, width: 80, height: 20, type: "platform" },
        { x: 950, y: 200, width: 80, height: 20, type: "platform" },
        { x: 1050, y: 280, width: 80, height: 20, type: "platform" },
        { x: 1150, y: 220, width: 80, height: 20, type: "platform" },
        { x: 1300, y: 350, width: 120, height: 20, type: "platform" },

        // Platforms leading to castle
        { x: 1500, y: 350, width: 100, height: 20, type: "platform" },
        { x: 1650, y: 300, width: 100, height: 20, type: "platform" },
        { x: 1800, y: 250, width: 100, height: 20, type: "platform" },
        { x: 1950, y: 300, width: 100, height: 20, type: "platform" },
        { x: 2100, y: 350, width: 100, height: 20, type: "platform" },
        { x: 2250, y: 380, width: 100, height: 20, type: "platform" }, // Castle approach

        // Bricks
        {
          x: 350,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 382,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 414,
          y: 368,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        // More challenging bricks
        {
          x: 850,
          y: 218,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 882,
          y: 218,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 1050,
          y: 248,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },
        {
          x: 1300,
          y: 318,
          width: 32,
          height: 32,
          type: "brick",
          breakable: true,
        },

        // Question blocks
        {
          x: 446,
          y: 368,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        {
          x: 550,
          y: 318,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        // More challenging question blocks
        {
          x: 950,
          y: 168,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },
        {
          x: 1150,
          y: 188,
          width: 32,
          height: 32,
          type: "question",
          used: false,
        },

        // Pipes
        { x: 700, y: 468, width: 64, height: 32, type: "pipe" },
      ];

      // Enemies - will be populated based on difficulty
      let enemies = [];

      // Bullet Bills (rockets)
      let bulletBills = [];

      // Bill Blasters (cannons that shoot Bullet Bills)
      let billBlasters = [];

      // Castle structure for Bowser
      let castle = {
        x: 2400,
        y: GROUND_LEVEL - 300,
        width: 400,
        height: 300,
        towers: [
          { x: 2400, y: GROUND_LEVEL - 350, width: 80, height: 350 },
          { x: 2720, y: GROUND_LEVEL - 350, width: 80, height: 350 },
        ],
        flags: [
          { x: 2420, y: GROUND_LEVEL - 380 },
          { x: 2740, y: GROUND_LEVEL - 380 },
        ],
      };

      // Projectiles for punch/shoot mechanic
      let projectiles = [];

      // Interior castle boss
      let interiorBoss = null;

      // Initial enemies based on difficulty (called after game starts)
      function initializeEnemies() {
        const difficulty = getDifficulty();
        enemies = [];

        // Base enemies - always present
        const baseEnemies = [
          { x: 400, type: "goomba" },
          { x: 600, type: "goomba" },
          { x: 750, type: "koopa" },
        ];

        // Additional enemies based on difficulty
        const additionalEnemies = [
          { x: 900, type: "goomba" },
          { x: 1000, type: "koopa" },
          { x: 1100, type: "goomba" },
          { x: 1200, type: "koopa" },
          { x: 1300, type: "goomba" },
          { x: 1400, type: "koopa" },
          { x: 1500, type: "goomba" },
        ];

        // Spawn base enemies
        baseEnemies.forEach((e) => {
          const speed = 1 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: e.x,
            y: GROUND_LEVEL - 32,
            width: 32,
            height: 32,
            velocityX: Math.random() < 0.5 ? -speed : speed,
            type: e.type,
            alive: true,
          });
        });

        // Spawn additional enemies based on difficulty count
        const extraCount = difficulty.initialEnemyCount - baseEnemies.length;
        for (
          let i = 0;
          i < Math.max(0, extraCount) && i < additionalEnemies.length;
          i++
        ) {
          const e = additionalEnemies[i];
          const speed = 1 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: e.x,
            y: GROUND_LEVEL - 32,
            width: 32,
            height: 32,
            velocityX: Math.random() < 0.5 ? -speed : speed,
            type: e.type,
            alive: true,
          });
        }

        // Dragon enemy - only on medium and hard
        if (selectedDifficulty !== "easy") {
          const dragonSpeed = 2 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: 550,
            y: 200,
            width: 48,
            height: 32,
            velocityX: dragonSpeed,
            velocityY: 0,
            type: "dragon",
            alive: true,
            health: 2,
            flightTimer: 0,
            fireTimer: 0,
          });
        }

        // Castle guard enemies - protect the castle
        const guardSpeed = 1.5 * difficulty.enemySpeedMultiplier;
        const castleGuards = [
          { x: 2200, type: "koopa" },
          { x: 2350, type: "koopa" },
          { x: 2450, type: "goomba" },
        ];

        castleGuards.forEach((guard) => {
          enemies.push({
            x: guard.x,
            y: GROUND_LEVEL - 32,
            width: 32,
            height: 32,
            velocityX: Math.random() < 0.5 ? -guardSpeed : guardSpeed,
            type: guard.type,
            alive: true,
          });
        });

        // Additional dragon guard near castle on medium and hard
        if (selectedDifficulty !== "easy") {
          const dragonSpeed = 2 * difficulty.enemySpeedMultiplier;
          enemies.push({
            x: 2300,
            y: 250,
            width: 48,
            height: 32,
            velocityX: dragonSpeed,
            velocityY: 0,
            type: "dragon",
            alive: true,
            health: 2,
            flightTimer: 0,
            fireTimer: 0,
          });
        }

        // Boss enemy - always present but harder on higher difficulties
        // Positioned in front of the castle
        enemies.push({
          x: 2550, // Positioned in front of castle entrance
          y: GROUND_LEVEL - 64,
          width: 64,
          height: 64,
          velocityX: 0,
          type: "bowser",
          alive: true,
          health:
            selectedDifficulty === "easy"
              ? 3
              : selectedDifficulty === "medium"
              ? 5
              : 8,
          directionChangeTimer: 0,
          entered: false,
        });
      }

      // Power-ups
      let powerUps = [];

      // Particles for effects
      let particles = [];

      // Lava hazards - initialized based on difficulty
      let lavaHazards = [];

      // Initialize lava based on difficulty (called in initializeObstacles)
      function initializeLava() {
        lavaHazards = [];
        // Only add lava on medium and hard difficulties
        if (selectedDifficulty !== "easy") {
          lavaHazards.push({
            x: 530, // Positioned under the dragon at x=550
            y: GROUND_LEVEL - 10,
            width: selectedDifficulty === "hard" ? 120 : 88,
            height: 20,
            type: "lava",
            damage: 1,
            timer: 1800,
          });
        }
      }

      // Obstacles (spikes, falling rocks)
      let obstacles = [];
      let fallingRocks = [];

      // Input handling
      let keys = {};

      // Update platform positions relative to GROUND_LEVEL for responsive design
      function updatePlatformPositions() {
        // Ground
        platforms[0].y = GROUND_LEVEL;

        // Platforms (relative to GROUND_LEVEL)
        platforms[1].y = GROUND_LEVEL - 100; // x: 300
        platforms[2].y = GROUND_LEVEL - 150; // x: 500
        platforms[3].y = GROUND_LEVEL - 200; // x: 650
        platforms[4].y = GROUND_LEVEL - 250; // x: 850
        platforms[5].y = GROUND_LEVEL - 300; // x: 950
        platforms[6].y = GROUND_LEVEL - 220; // x: 1050
        platforms[7].y = GROUND_LEVEL - 280; // x: 1150
        platforms[8].y = GROUND_LEVEL - 150; // x: 1300

        // Platforms leading to castle
        platforms[9].y = GROUND_LEVEL - 150; // x: 1500
        platforms[10].y = GROUND_LEVEL - 200; // x: 1650
        platforms[11].y = GROUND_LEVEL - 250; // x: 1800
        platforms[12].y = GROUND_LEVEL - 200; // x: 1950
        platforms[13].y = GROUND_LEVEL - 150; // x: 2100
        platforms[14].y = GROUND_LEVEL - 120; // x: 2250 (Castle approach)

        // Bricks (32px above their respective platforms)
        platforms[15].y = GROUND_LEVEL - 132; // x: 350 (above platform 1)
        platforms[16].y = GROUND_LEVEL - 132; // x: 382
        platforms[17].y = GROUND_LEVEL - 132; // x: 414
        platforms[18].y = GROUND_LEVEL - 282; // x: 850 (above platform 4)
        platforms[19].y = GROUND_LEVEL - 282; // x: 882
        platforms[20].y = GROUND_LEVEL - 252; // x: 1050 (above platform 6)
        platforms[21].y = GROUND_LEVEL - 182; // x: 1300 (above boss platform)

        // Question blocks
        platforms[22].y = GROUND_LEVEL - 132; // x: 446
        platforms[23].y = GROUND_LEVEL - 182; // x: 550
        platforms[24].y = GROUND_LEVEL - 332; // x: 950 (above platform 5)
        platforms[25].y = GROUND_LEVEL - 312; // x: 1150 (above platform 7)

        // Pipe
        platforms[26].y = GROUND_LEVEL - 32; // x: 700
      }

      // Update castle positions based on GROUND_LEVEL
      function updateCastlePositions() {
        castle.y = GROUND_LEVEL - 300;
        castle.height = 300;
        castle.towers[0].y = GROUND_LEVEL - 350;
        castle.towers[0].height = 350;
        castle.towers[1].y = GROUND_LEVEL - 350;
        castle.towers[1].height = 350;
        castle.flags[0].y = GROUND_LEVEL - 380;
        castle.flags[1].y = GROUND_LEVEL - 380;
      }

      // Initialize game
      function init() {
        canvas = document.getElementById("game-canvas");
        ctx = canvas.getContext("2d");

        // Set canvas dimensions dynamically for responsiveness
        const container = document.getElementById("game-container");
        CANVAS_WIDTH = container.clientWidth;
        CANVAS_HEIGHT = container.clientHeight;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Set ground level based on canvas height
        GROUND_LEVEL = CANVAS_HEIGHT - 100;

        // Update Mario's initial position based on new ground level
        mario.y = GROUND_LEVEL - 32;

        // Update all initial platform and object positions relative to GROUND_LEVEL
        updatePlatformPositions();
        updateCastlePositions();

        // Initialize audio
        initAudio();

        // Event listeners
        document.addEventListener("keydown", (e) => {
          keys[e.code] = true;
        });

        document.addEventListener("keyup", (e) => {
          keys[e.code] = false;
        });

        // Handle window resize for responsive canvas
        window.addEventListener("resize", () => {
          const container = document.getElementById("game-container");
          CANVAS_WIDTH = container.clientWidth;
          CANVAS_HEIGHT = container.clientHeight;
          canvas.width = CANVAS_WIDTH;
          canvas.height = CANVAS_HEIGHT;

          // Update ground level based on new canvas height
          GROUND_LEVEL = CANVAS_HEIGHT - 100;

          // Update Mario's position based on new ground level
          if (!gameRunning) {
            mario.y = GROUND_LEVEL - 32;
            // Update all platform positions
            updatePlatformPositions();
            updateCastlePositions();
          } else {
            // If game is running, ensure Mario doesn't fall through the ground
            if (mario.y + mario.height > GROUND_LEVEL) {
              mario.y = GROUND_LEVEL - mario.height;
            }
          }

          // Clear and redraw if game is running
          if (gameRunning) {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          }
        });

        // Touch controls for mobile/iPad
        setupTouchControls();

        // Don't start background music automatically - wait for user interaction
        // startBackgroundMusic(); // Commented out to require user interaction

        // Start game loop
        gameLoop = setInterval(update, 1000 / 60); // 60 FPS
        setInterval(updateTimer, 1000); // Update timer every second
      }

      // Main game update loop
      function update() {
        if (!gameRunning) return;

        handleInput();
        updateMario();

        if (insideCastle) {
          // Inside castle - different update logic
          updateProjectiles();
          updateInteriorBoss();
          checkInteriorCollisions();
        } else {
          // Outside castle - normal game logic
          updateEnemies();
          updatePowerUps();
          updateLava();
          updateObstacles(); // Update spikes and falling rocks
          updateBulletBills(); // Update Bullet Bills
          generateGround(); // Generate infinite ground
          generatePlatforms(); // Procedural generation
          updateFlyingPlatforms(); // Update flying platform positions
          generateEnemies(); // Procedural generation
          generateObstacles(); // Generate spikes and rocks
          generateBillBlasters(); // Generate Bill Blasters
          checkCollisions();
          checkCastleEntrance(); // Check if player is near castle entrance
        }

        updateParticles();
        render();

        // Camera follow - smooth following for infinite level (disabled inside castle)
        if (!insideCastle) {
          const targetCameraX = Math.max(0, mario.x - CANVAS_WIDTH / 2);
          cameraX = targetCameraX;
        } else {
          cameraX = 0; // Fixed camera inside castle
        }
      }

      // Handle player input
      function handleInput() {
        // Castle entrance - press E to enter
        if (keys["KeyE"] && showEnterPrompt && !insideCastle) {
          enterCastle();
          keys["KeyE"] = false; // Prevent repeated entry
        }

        // Exit castle - press E to exit
        if (
          keys["KeyE"] &&
          insideCastle &&
          interiorBoss &&
          !interiorBoss.alive
        ) {
          exitCastle();
          keys["KeyE"] = false; // Prevent repeated exit
        }

        // Punch/Shoot mechanic - press F or Shift
        if (keys["KeyF"] || keys["ShiftLeft"] || keys["ShiftRight"]) {
          if (!mario.punchCooldown || mario.punchCooldown <= 0) {
            shootProjectile();
            mario.punchCooldown = 30; // 0.5 second cooldown at 60fps
          }
          keys["KeyF"] = false;
          keys["ShiftLeft"] = false;
          keys["ShiftRight"] = false;
        }

        // Reduce punch cooldown
        if (mario.punchCooldown > 0) {
          mario.punchCooldown--;
        }

        // Horizontal movement
        if (keys["ArrowLeft"] || keys["KeyA"]) {
          mario.velocityX = -MOVE_SPEED;
          mario.facing = "left";
        } else if (keys["ArrowRight"] || keys["KeyD"]) {
          mario.velocityX = MOVE_SPEED;
          mario.facing = "right";
        } else {
          mario.velocityX = 0;
        }

        // Jumping (enabled everywhere)
        if (
          (keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) &&
          mario.onGround
        ) {
          mario.velocityY = JUMP_FORCE;
          mario.onGround = false;
          playJumpSound();
        }
      }

      // Shoot projectile (punch mechanic)
      function shootProjectile() {
        const projectileSpeed = 8;
        const offsetX = mario.facing === "right" ? mario.width : -16;

        projectiles.push({
          x: mario.x + offsetX,
          y: mario.y + mario.height / 2 - 8,
          width: 16,
          height: 16,
          velocityX:
            mario.facing === "right" ? projectileSpeed : -projectileSpeed,
          facing: mario.facing,
          alive: true,
        });

        // Play shoot sound
        playJumpSound(); // Reuse jump sound for now
      }

      // Enter castle
      function enterCastle() {
        insideCastle = true;
        showEnterPrompt = false;

        // Save outdoor position
        mario.outdoorX = mario.x;
        mario.outdoorY = mario.y;

        // Move Mario to castle interior start position
        mario.x = 100;
        mario.y = GROUND_LEVEL - mario.height;
        mario.velocityX = 0;
        mario.velocityY = 0;

        // Initialize interior boss
        initializeInteriorBoss();

        // Play sound
        playPowerUpSound();
      }

      // Exit castle
      function exitCastle() {
        insideCastle = false;

        // Restore outdoor position (in front of castle)
        mario.x = castle.x + castle.width / 2;
        mario.y = GROUND_LEVEL - mario.height;
        mario.velocityX = 0;
        mario.velocityY = 0;

        // Clear interior boss
        interiorBoss = null;

        // Play sound
        playPowerUpSound();
      }

      // Initialize interior boss
      function initializeInteriorBoss() {
        const difficulty = getDifficulty();
        interiorBoss = {
          x: CANVAS_WIDTH - 200,
          y: GROUND_LEVEL - 80,
          width: 80,
          height: 80,
          velocityX: 0,
          velocityY: 0,
          type: "interior_bowser",
          alive: true,
          health:
            selectedDifficulty === "easy"
              ? 5
              : selectedDifficulty === "medium"
              ? 8
              : 12,
          attackTimer: 0,
          moveTimer: 0,
        };
      }

      // Update Mario
      function updateMario() {
        // Apply gravity
        mario.velocityY += GRAVITY;

        // Update position
        mario.x += mario.velocityX;
        mario.y += mario.velocityY;

        // Reset onGround status
        mario.onGround = false;

        // Ground collision
        if (mario.y + mario.height >= GROUND_LEVEL) {
          mario.y = GROUND_LEVEL - mario.height;
          mario.velocityY = 0;
          mario.onGround = true;
        }

        // Platform collisions
        platforms.forEach((platform) => {
          if (checkCollision(mario, platform)) {
            if (mario.velocityY > 0 && mario.y < platform.y) {
              // Landing on platform
              mario.y = platform.y - mario.height;
              mario.velocityY = 0;
              mario.onGround = true;
            } else if (mario.velocityY < 0 && mario.y > platform.y) {
              // Hitting platform from below
              mario.y = platform.y + platform.height;
              mario.velocityY = 0;
            }

            // Handle brick/question block interactions
            if (
              platform.type === "brick" &&
              mario.velocityY < 0 &&
              platform.breakable
            ) {
              platform.breakable = false;
              score += 50;
              playBreakSound();
            } else if (
              platform.type === "question" &&
              mario.velocityY < 0 &&
              !platform.used
            ) {
              platform.used = true;
              spawnPowerUp(platform.x, platform.y - 32);
              score += 100;
              playCoinSound();
            }

            // Portal interactions are now only for enemies, not Mario
          }
        });

        // Keep Mario in bounds
        if (mario.x < 0) mario.x = 0;
        // No right boundary - infinite level!
      }

      // Check if player is near castle entrance
      function checkCastleEntrance() {
        if (!castle) return;

        const entranceX = castle.x + castle.width / 2 - 50;
        const entranceY = castle.y + castle.height - 120;
        const entranceWidth = 100;
        const entranceHeight = 120;

        // Check if Mario is near the entrance and Bowser is defeated
        const nearEntrance =
          mario.x + mario.width > entranceX &&
          mario.x < entranceX + entranceWidth &&
          mario.y + mario.height > entranceY &&
          mario.y < entranceY + entranceHeight;

        const bowserDefeated = !enemies.some(
          (e) => e.type === "bowser" && e.alive
        );

        showEnterPrompt = nearEntrance && bowserDefeated;
      }

      // Update projectiles
      function updateProjectiles() {
        projectiles.forEach((projectile, index) => {
          if (!projectile.alive) {
            projectiles.splice(index, 1);
            return;
          }

          projectile.x += projectile.velocityX;

          // Remove if off screen
          if (projectile.x < -50 || projectile.x > CANVAS_WIDTH + 50) {
            projectiles.splice(index, 1);
          }
        });
      }

      // Update interior boss
      function updateInteriorBoss() {
        if (!interiorBoss || !interiorBoss.alive) return;

        const boss = interiorBoss;

        // Move timer for simple movement pattern
        boss.moveTimer++;
        if (boss.moveTimer < 120) {
          boss.velocityX = 2;
        } else if (boss.moveTimer < 240) {
          boss.velocityX = -2;
        } else {
          boss.moveTimer = 0;
        }

        boss.x += boss.velocityX;

        // Keep boss in bounds
        if (boss.x < CANVAS_WIDTH / 2) boss.x = CANVAS_WIDTH / 2;
        if (boss.x + boss.width > CANVAS_WIDTH - 50)
          boss.x = CANVAS_WIDTH - 50 - boss.width;

        // Attack timer - boss shoots fireballs
        boss.attackTimer++;
        if (boss.attackTimer > 90) {
          // Attack every 1.5 seconds
          boss.attackTimer = 0;

          // Shoot fireball at Mario
          const fireballSpeed = 4;
          const dx = mario.x - boss.x;
          const dy = mario.y - boss.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          projectiles.push({
            x: boss.x + boss.width / 2,
            y: boss.y + boss.height / 2,
            width: 20,
            height: 20,
            velocityX: (dx / distance) * fireballSpeed,
            velocityY: (dy / distance) * fireballSpeed,
            facing: dx > 0 ? "right" : "left",
            alive: true,
            enemy: true, // Mark as enemy projectile
          });

          playBreakSound();
        }
      }

      // Check collisions inside castle
      function checkInteriorCollisions() {
        if (!interiorBoss || !interiorBoss.alive) return;

        // Player projectiles vs boss
        projectiles.forEach((projectile, index) => {
          if (projectile.enemy) return; // Skip enemy projectiles

          if (checkCollision(projectile, interiorBoss)) {
            projectile.alive = false;
            projectiles.splice(index, 1);

            interiorBoss.health--;
            score += 500;
            playBreakSound();

            // Create hit particles
            for (let i = 0; i < 10; i++) {
              particles.push({
                x: projectile.x,
                y: projectile.y,
                velocityX: (Math.random() - 0.5) * 6,
                velocityY: (Math.random() - 0.5) * 6,
                life: 20,
                color: "#FF4500",
                size: 4 + Math.random() * 4,
              });
            }

            if (interiorBoss.health <= 0) {
              interiorBoss.alive = false;
              score += 10000;
              playPowerUpSound();

              // Victory particles
              for (let i = 0; i < 50; i++) {
                particles.push({
                  x: interiorBoss.x + interiorBoss.width / 2,
                  y: interiorBoss.y + interiorBoss.height / 2,
                  velocityX: (Math.random() - 0.5) * 10,
                  velocityY: (Math.random() - 0.5) * 10,
                  life: 40,
                  color: ["#FFD700", "#FF4500", "#00FF00"][
                    Math.floor(Math.random() * 3)
                  ],
                  size: 6 + Math.random() * 6,
                });
              }
            }
          }
        });

        // Enemy projectiles vs Mario
        projectiles.forEach((projectile, index) => {
          if (!projectile.enemy) return; // Skip player projectiles

          if (checkCollision(projectile, mario)) {
            projectile.alive = false;
            projectiles.splice(index, 1);
            loseLife();
            playBreakSound();
          }
        });
      }

      // Update enemies
      function updateEnemies() {
        enemies.forEach((enemy, index) => {
          if (!enemy.alive) return;

          enemy.x += enemy.velocityX;
          enemy.y += enemy.velocityY; // Update y position for flying enemies

          // Simple AI - reverse direction at platform edges
          let onPlatform = false;
          platforms.forEach((platform) => {
            if (
              enemy.x + enemy.width > platform.x &&
              enemy.x < platform.x + platform.width &&
              enemy.y + enemy.height >= platform.y - 5 &&
              enemy.y + enemy.height <= platform.y + 10
            ) {
              onPlatform = true;
            }
          });

          if (!onPlatform) {
            enemy.velocityX *= -1;
          }

          // Special dragon AI
          if (enemy.type === "dragon") {
            enemy.flightTimer++;
            enemy.fireTimer--;

            // Flying pattern - sinusoidal vertical movement
            enemy.velocityY = Math.sin(enemy.flightTimer * 0.05) * 2;

            // Horizontal movement with occasional direction changes
            if (enemy.flightTimer % 200 === 0) {
              enemy.velocityX *= -1; // Reverse direction
            }

            // Fire breath every few seconds
            if (enemy.flightTimer % 300 === 0) {
              enemy.fireTimer = 20; // Fire for 20 frames
            }

            // Keep dragon in air
            if (enemy.y < 100) enemy.y = 100;
            if (enemy.y > 300) enemy.y = 300;
          }

          // Special boss AI
          if (enemy.type === "bowser") {
            // Boss guards the castle - becomes active when Mario approaches
            if (!enemy.entered && mario.x > castle.x - 300) {
              enemy.entered = true;
              enemy.velocityX = -2; // Start moving to defend castle
              playBossEntranceSound(); // Dramatic entrance sound
              createTeleportParticles(enemy.x, enemy.y); // Entrance particles
            }

            // Only activate aggressive AI after boss has entered
            if (enemy.entered) {
              enemy.directionChangeTimer++;
              if (enemy.directionChangeTimer > 120) {
                // Change direction every 2 seconds
                enemy.velocityX *= -1;
                enemy.directionChangeTimer = 0;
              }
              // Boss is faster and more aggressive, but stays near castle
              const distanceFromCastle = Math.abs(
                enemy.x - castle.x - castle.width / 2
              );
              if (distanceFromCastle > 400) {
                // Return to castle if too far
                enemy.velocityX = enemy.x < castle.x ? 3 : -3;
              } else {
                enemy.velocityX = enemy.velocityX > 0 ? 3 : -3;
              }
            }
          }

          // Keep enemies in bounds - remove if too far from camera
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (enemy.x < cameraLeft || enemy.x > cameraRight) {
            enemies.splice(index, 1);
          }
        });
      }

      // Procedural generation system
      let nextPlatformX = 1700; // Start generating after initial platforms
      let nextEnemyX = 1800;
      let nextGroundX = 800; // Start extending ground
      let nextObstacleX = 500; // Start generating obstacles early
      let nextBlasterX = 600; // Start generating Bill Blasters early

      // Generate infinite ground
      function generateGround() {
        while (nextGroundX < mario.x + CANVAS_WIDTH * 2) {
          platforms.push({
            x: nextGroundX,
            y: GROUND_LEVEL,
            width: 800, // Overlapping chunks for seamless ground
            height: 100,
            type: "ground",
          });
          nextGroundX += 800;
        }
      }

      // Generate random platforms as Mario progresses
      function generatePlatforms() {
        // Only generate if Mario is approaching
        while (nextPlatformX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextPlatformX;

          // Calculate difficulty based on distance
          const distanceTraveled = x;
          const difficultyFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Platform height gets more varied with distance
          const heightVariation = 150 + difficultyFactor * 100; // 150 -> 250
          const y = 250 + Math.random() * heightVariation;

          // Flying platforms become more common (10% -> 30%)
          const flyingChance = 0.1 + difficultyFactor * 0.2;
          const isFlying = Math.random() < flyingChance;

          // Flying platforms move faster and more erratically at higher difficulties
          const flightSpeed = isFlying
            ? 0.02 + Math.random() * 0.03 + difficultyFactor * 0.02
            : 0;
          const flightRadius = isFlying
            ? 50 + Math.random() * 100 + difficultyFactor * 50
            : 0;

          const platformType = Math.random();

          // Increased spawn rates for more consistent blocks
          if (platformType < 0.35) {
            // Floating platform (35%)
            // Platforms get smaller with distance (harder to land on)
            const platformWidth = 180 - difficultyFactor * 60; // 180 -> 120
            platforms.push({
              x: x,
              y: y,
              width: platformWidth,
              height: 20,
              type: "platform",
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.55) {
            // Brick (20%)
            platforms.push({
              x: x,
              y: y,
              width: 32,
              height: 32,
              type: "brick",
              breakable: true,
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.6,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.75) {
            // Question block (20%)
            platforms.push({
              x: x,
              y: y,
              width: 32,
              height: 32,
              type: "question",
              used: false,
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.6,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          } else if (platformType < 0.85) {
            // Pipe on ground (10%)
            platforms.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 64,
              height: 32,
              type: "pipe",
              flying: isFlying,
              flightAngle: isFlying ? Math.random() * Math.PI * 2 : 0,
              flightRadius: flightRadius * 0.8,
              flightSpeed: flightSpeed,
              originalY: isFlying ? y : 0,
            });
          }
          // 15% chance of nothing - gaps get wider with difficulty

          // Platform spacing increases with difficulty (gaps get wider)
          const minGap = 120 + difficultyFactor * 30; // 120 -> 150
          const gapVariation = 180 + difficultyFactor * 70; // 180 -> 250
          nextPlatformX += minGap + Math.random() * gapVariation;
        }
      }

      // Update flying platforms - make them move in circular patterns
      function updateFlyingPlatforms() {
        platforms.forEach((platform) => {
          if (platform.flying) {
            // Update flight angle
            platform.flightAngle += platform.flightSpeed;

            // Calculate vertical movement using sine wave
            const verticalOffset =
              Math.sin(platform.flightAngle) * platform.flightRadius;

            // Update platform Y position
            platform.y = platform.originalY + verticalOffset;

            // Optional: Add horizontal movement for more dynamic flying
            // platform.x += Math.cos(platform.flightAngle) * 0.5;
          }
        });
      }

      // Generate random enemies as Mario progresses
      function generateEnemies() {
        const difficulty = getDifficulty();

        // Only generate if Mario is approaching
        while (nextEnemyX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextEnemyX;

          // Calculate difficulty multiplier based on distance traveled
          // Early game (0-1000): mostly easy enemies
          // Mid game (1000-3000): mix of all enemies
          // Late game (3000+): more dragons and harder enemies
          const distanceTraveled = x;
          const distanceFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Adjust spawn rates based on difficulty settings
          const dragonChance =
            difficulty.dragonChanceBase +
            distanceFactor *
              (difficulty.dragonChanceMax - difficulty.dragonChanceBase);
          const koopaChance = 0.3; // stays at 30%
          const goombaChance = 1 - dragonChance - koopaChance;

          const enemyType = Math.random();

          if (enemyType < goombaChance) {
            // Goomba - speed affected by difficulty
            const speed =
              (1 + distanceFactor * 0.5) * difficulty.enemySpeedMultiplier;
            enemies.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 32,
              height: 32,
              velocityX: Math.random() < 0.5 ? -speed : speed,
              type: "goomba",
              alive: true,
            });
          } else if (enemyType < goombaChance + koopaChance) {
            // Koopa - speed affected by difficulty
            const speed =
              (1 + distanceFactor * 0.8) * difficulty.enemySpeedMultiplier;
            enemies.push({
              x: x,
              y: GROUND_LEVEL - 32,
              width: 32,
              height: 32,
              velocityX: Math.random() < 0.5 ? -speed : speed,
              type: "koopa",
              alive: true,
            });
          } else {
            // Flying dragon with lava underneath - speed and health affected by difficulty
            const dragonY = 150 + Math.random() * 100;
            const speed =
              (2 + distanceFactor * 1) * difficulty.enemySpeedMultiplier;
            const health = 2 + Math.floor(distanceFactor * 2);

            // Calculate lava width for spacing check
            const lavaWidth = difficulty.lavaWidth + distanceFactor * 32;
            const newLavaX = x - 20;

            // Check if this dragon would be too close to existing dragons
            let canSpawnDragon = true;
            for (const hazard of lavaHazards) {
              if (hazard.type === "lava") {
                // Check if this lava hazard overlaps or is too close to existing lava
                // Need at least one lava width of space between lava hazards
                const minDistance = lavaWidth;
                const distance = Math.abs(
                  newLavaX + lavaWidth / 2 - (hazard.x + hazard.width / 2)
                );
                const combinedHalfWidths = (lavaWidth + hazard.width) / 2;

                if (distance < combinedHalfWidths + minDistance) {
                  canSpawnDragon = false;
                  break;
                }
              }
            }

            // Only spawn dragon if there's enough space
            if (canSpawnDragon) {
              enemies.push({
                x: x,
                y: dragonY,
                width: 48,
                height: 32,
                velocityX: Math.random() < 0.5 ? -speed : speed,
                velocityY: 0,
                type: "dragon",
                alive: true,
                health: health,
                flightTimer: 0,
                fireTimer: 0,
              });

              // Add lava underneath the dragon - width based on difficulty
              lavaHazards.push({
                x: newLavaX,
                y: GROUND_LEVEL - 10,
                width: lavaWidth,
                height: 20,
                type: "lava",
                damage: 1,
                timer: 999999, // Lava lasts essentially forever
              });
            } else {
              // If we can't spawn a dragon due to spacing, try spawning a different enemy instead
              // Spawn a goomba instead to maintain enemy density
              enemies.push({
                x: x,
                y: GROUND_LEVEL - 32,
                width: 32,
                height: 32,
                velocityX: Math.random() < 0.5 ? -speed : speed,
                type: "goomba",
                alive: true,
              });
            }
          }

          // Enemy spawn rate based on difficulty settings
          const spawnGap =
            difficulty.spawnGapBase -
            distanceFactor * difficulty.spawnGapReduction;
          nextEnemyX += spawnGap + Math.random() * 150;
        }
      }

      // Update power-ups
      function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const powerUp = powerUps[i];
          powerUp.y += powerUp.velocityY;
          powerUp.velocityY += GRAVITY;

          // Ground collision
          if (powerUp.y + powerUp.height >= GROUND_LEVEL) {
            powerUp.y = GROUND_LEVEL - powerUp.height;
            powerUp.velocityY = 0;
          }

          // Remove power-ups that are off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (powerUp.x < cameraLeft || powerUp.x > cameraRight) {
            powerUps.splice(i, 1);
          }
        }
      }

      // Spawn power-up
      function spawnPowerUp(x, y) {
        powerUps.push({
          x: x,
          y: y,
          width: 32,
          height: 32,
          velocityY: -8,
          type: Math.random() < 0.7 ? "mushroom" : "fireflower",
        });
      }

      // Update particles
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];
          particle.x += particle.velocityX;
          particle.y += particle.velocityY;
          particle.velocityY += 0.1; // Gravity
          particle.life--;

          // Remove dead particles or particles off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3; // Increased range for infinite level
          if (
            particle.life <= 0 ||
            particle.x < cameraLeft ||
            particle.x > cameraRight
          ) {
            particles.splice(i, 1);
          }
        }
      }

      // Update lava hazards
      function updateLava() {
        for (let i = lavaHazards.length - 1; i >= 0; i--) {
          const lava = lavaHazards[i];
          lava.timer--;

          // Remove expired lava or lava off-screen
          const cameraLeft = cameraX - CANVAS_WIDTH;
          const cameraRight = cameraX + CANVAS_WIDTH * 3;
          if (
            lava.timer <= 0 ||
            lava.x + lava.width < cameraLeft ||
            lava.x > cameraRight
          ) {
            lavaHazards.splice(i, 1);
          }
        }
      }

      // Update obstacles (spikes and falling rocks)
      function updateObstacles() {
        const cameraLeft = cameraX - CANVAS_WIDTH;
        const cameraRight = cameraX + CANVAS_WIDTH * 3;

        // Update spikes - remove off-screen ones
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obstacle = obstacles[i];
          if (
            obstacle.x + obstacle.width < cameraLeft ||
            obstacle.x > cameraRight
          ) {
            obstacles.splice(i, 1);
          }
        }

        // Update falling rocks
        for (let i = fallingRocks.length - 1; i >= 0; i--) {
          const rock = fallingRocks[i];

          // Apply gravity
          rock.velocityY += 0.3;
          rock.y += rock.velocityY;
          rock.rotation += rock.rotationSpeed;

          // Remove rocks that hit the ground or are off-screen
          if (
            rock.y > GROUND_LEVEL ||
            rock.x < cameraLeft ||
            rock.x > cameraRight
          ) {
            // Create impact particles
            if (rock.y > GROUND_LEVEL - 20) {
              for (let j = 0; j < 5; j++) {
                particles.push({
                  x: rock.x + rock.width / 2,
                  y: GROUND_LEVEL,
                  velocityX: (Math.random() - 0.5) * 4,
                  velocityY: -Math.random() * 3,
                  life: 20,
                  color: "#8B4513",
                  size: 3 + Math.random() * 3,
                });
              }
            }
            fallingRocks.splice(i, 1);
          }
        }

        // Spawn new falling rocks near Mario
        const difficulty = getDifficulty();
        if (Math.random() < difficulty.rockSpawnRate * 0.01) {
          // Spawn rock ahead of Mario
          const spawnX = mario.x + CANVAS_WIDTH * 0.5 + Math.random() * 200;
          fallingRocks.push({
            x: spawnX,
            y: -50,
            width: 24 + Math.random() * 16,
            height: 24 + Math.random() * 16,
            velocityY: 1 + Math.random() * 2,
            rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.2,
          });
        }
      }

      // Generate obstacles as Mario progresses
      function generateObstacles() {
        const difficulty = getDifficulty();

        // Generate spikes
        while (nextObstacleX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextObstacleX;

          // Spike spawn based on difficulty
          if (Math.random() < difficulty.spikeSpawnRate) {
            // Create spike trap on ground
            const spikeCount = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < spikeCount; i++) {
              obstacles.push({
                x: x + i * 24,
                y: GROUND_LEVEL - 20,
                width: 24,
                height: 20,
                type: "spike",
              });
            }
          }

          // Increase gap between obstacle spawn points
          nextObstacleX += 200 + Math.random() * 300;
        }
      }

      // Generate Bill Blasters (cannons) as Mario progresses
      function generateBillBlasters() {
        const difficulty = getDifficulty();

        // Easy difficulty has no rockets at all
        if (selectedDifficulty === "easy") {
          return;
        }

        // Only generate if Mario is approaching
        while (nextBlasterX < mario.x + CANVAS_WIDTH * 2) {
          const x = nextBlasterX;

          // Calculate difficulty based on distance
          const distanceTraveled = x;
          const distanceFactor = Math.min(distanceTraveled / 3000, 1); // 0 to 1

          // Blaster spawn rate based on difficulty
          let baseSpawnChance;
          if (selectedDifficulty === "medium") {
            // Medium: Very low spawn rate, increases slowly
            baseSpawnChance = 0.05 + distanceFactor * 0.05; // 5% -> 10%
          } else {
            // Hard: Low spawn rate, increases moderately
            baseSpawnChance = 0.08 + distanceFactor * 0.08; // 8% -> 16%
          }

          if (Math.random() < baseSpawnChance) {
            // Random placement - can be on ground or elevated
            const placementType = Math.random();
            let y, height;

            if (placementType < 0.5) {
              // Ground-level blaster
              y = GROUND_LEVEL - 48;
              height = 48;
            } else if (placementType < 0.8) {
              // Mid-height blaster
              y = GROUND_LEVEL - 200;
              height = 48;
            } else {
              // High blaster
              y = 150;
              height = 48;
            }

            // Add Bill Blaster
            billBlasters.push({
              x: x,
              y: y,
              width: 48,
              height: height,
              type: "blaster",
              shootTimer: Math.random() * 120 + 60, // Shoot every 60-180 frames
              shootCooldown:
                selectedDifficulty === "medium"
                  ? 300 - distanceFactor * 30
                  : 180 - distanceFactor * 30, // Medium shoots much slower, Hard shoots slower
            });
          }

          // Spacing between potential blaster spawns (larger gaps to reduce frequency)
          const baseSpacing = selectedDifficulty === "medium" ? 600 : 450;
          const spacingVariation = selectedDifficulty === "medium" ? 800 : 600;
          nextBlasterX += baseSpacing + Math.random() * spacingVariation;
        }
      }

      // Update Bullet Bills
      function updateBulletBills() {
        const cameraLeft = cameraX - CANVAS_WIDTH;
        const cameraRight = cameraX + CANVAS_WIDTH * 3;
        const difficulty = getDifficulty();

        // Update existing Bullet Bills
        for (let i = bulletBills.length - 1; i >= 0; i--) {
          const bullet = bulletBills[i];

          // Move Bullet Bill
          bullet.x += bullet.velocityX;

          // Remove if off-screen
          if (bullet.x < cameraLeft || bullet.x > cameraRight) {
            bulletBills.splice(i, 1);
            continue;
          }
        }

        // Update Bill Blasters and spawn new Bullet Bills
        for (let i = billBlasters.length - 1; i >= 0; i--) {
          const blaster = billBlasters[i];

          // Remove blasters that are too far off-screen
          if (
            blaster.x + blaster.width < cameraLeft ||
            blaster.x > cameraRight
          ) {
            billBlasters.splice(i, 1);
            continue;
          }

          // Update shoot timer
          blaster.shootTimer--;

          // Spawn Bullet Bill when timer reaches 0
          if (blaster.shootTimer <= 0 && blaster.x < mario.x + CANVAS_WIDTH) {
            // Only shoot if on screen or close to it
            const distanceTraveled = blaster.x;
            const distanceFactor = Math.min(distanceTraveled / 3000, 1);

            // Determine direction - shoot towards Mario's general direction
            const shootLeft = blaster.x > mario.x;
            // Adjust speed based on difficulty - medium is slower than base
            let speedMultiplier = difficulty.enemySpeedMultiplier;
            if (selectedDifficulty === "medium") {
              speedMultiplier *= 0.8; // Medium rockets are 20% slower
            }
            const speed = (4 + distanceFactor * 2) * speedMultiplier;

            // Create Bullet Bill
            bulletBills.push({
              x: blaster.x + (shootLeft ? -32 : blaster.width),
              y: blaster.y + blaster.height / 2 - 16, // Center on blaster
              width: 32,
              height: 32,
              velocityX: shootLeft ? -speed : speed,
              type: "bullet",
              alive: true,
            });

            // Play shoot sound
            playBeep(200, 0.1, "square");

            // Reset timer
            blaster.shootTimer = blaster.shootCooldown;
          }
        }
      }

      // Check collisions
      function checkCollisions() {
        // Mario vs enemies
        enemies.forEach((enemy, enemyIndex) => {
          if (enemy.alive && checkCollision(mario, enemy)) {
            // Check if Mario jumped on enemy - more lenient for dragon due to wings
            let jumpedOnEnemy = false;
            if (mario.velocityY > 0) {
              if (enemy.type === "dragon") {
                // Dragon jumping is very lenient - if falling on dragon from above, it counts as a kill
                jumpedOnEnemy =
                  mario.y + mario.height * 0.5 < enemy.y + enemy.height;
              } else {
                // Standard jumping logic for other enemies
                jumpedOnEnemy = mario.y < enemy.y;
              }
            }

            if (jumpedOnEnemy) {
              // Mario jumped on enemy
              if (enemy.type === "bowser") {
                // Boss takes multiple hits
                enemy.health--;
                mario.velocityY = JUMP_FORCE * 0.8; // Higher bounce off boss
                score += 500; // More points for hitting boss
                playBreakSound(); // Sound for damaging boss

                // Update boss health display
                document.getElementById("boss-health-value").textContent =
                  enemy.health;
                document.getElementById("boss-health").style.display = "block";

                if (enemy.health <= 0) {
                  enemy.alive = false;
                  score += 5000; // Bonus for defeating boss
                  playPowerUpSound(); // Victory sound
                  document.getElementById("boss-health").style.display = "none";
                  document.getElementById("boss-warning").style.display =
                    "none";
                  document.getElementById("victory-message").style.display =
                    "block";
                }
              } else if (enemy.type === "dragon") {
                // Dragon takes 2 hits to defeat
                enemy.health = (enemy.health || 2) - 1;
                mario.velocityY = JUMP_FORCE * 0.7; // Bounce off dragon
                score += 300; // Points for hitting dragon

                if (enemy.health <= 0) {
                  enemy.alive = false;
                  score += 1000; // Bonus for defeating dragon
                  playPowerUpSound(); // Victory sound
                } else {
                  playBreakSound(); // Sound for damaging dragon
                }
              } else {
                // Regular enemies die in one hit
                enemy.alive = false;
                mario.velocityY = JUMP_FORCE * 0.5; // Small bounce
                score += 100;
                playEnemyDefeatSound();
              }
            } else {
              // Mario hit by enemy
              if (enemy.type === "dragon" && enemy.fireTimer > 0) {
                // Dragon fire is extra dangerous - double damage
                loseLife();
                loseLife();
              } else {
                loseLife();
              }
            }
          }
        });

        // Mario vs lava hazards
        lavaHazards.forEach((lava) => {
          if (checkCollision(mario, lava)) {
            // Lava damage - lose life immediately
            loseLife();
            // Add burn particles
            for (let i = 0; i < 8; i++) {
              particles.push({
                x: mario.x + 16,
                y: mario.y + 16,
                velocityX: (Math.random() - 0.5) * 4,
                velocityY: -Math.random() * 2,
                life: 20,
                color: Math.random() < 0.5 ? "#FF4500" : "#FFD700",
                size: 3 + Math.random() * 3,
              });
            }
          }
        });

        // Mario vs spikes
        obstacles.forEach((obstacle) => {
          if (obstacle.type === "spike" && checkCollision(mario, obstacle)) {
            playSpikeSound();
            loseLife();
            // Add spike hit particles
            for (let i = 0; i < 6; i++) {
              particles.push({
                x: mario.x + 16,
                y: mario.y + mario.height,
                velocityX: (Math.random() - 0.5) * 3,
                velocityY: -Math.random() * 4,
                life: 15,
                color: "#A0A0A0",
                size: 2 + Math.random() * 2,
              });
            }
          }
        });

        // Mario vs falling rocks
        for (let i = fallingRocks.length - 1; i >= 0; i--) {
          const rock = fallingRocks[i];
          if (checkCollision(mario, rock)) {
            playBreakSound();
            loseLife();
            fallingRocks.splice(i, 1);
            // Add rock break particles
            for (let j = 0; j < 8; j++) {
              particles.push({
                x: rock.x + rock.width / 2,
                y: rock.y + rock.height / 2,
                velocityX: (Math.random() - 0.5) * 5,
                velocityY: (Math.random() - 0.5) * 5,
                life: 25,
                color: Math.random() < 0.5 ? "#8B4513" : "#A0522D",
                size: 4 + Math.random() * 4,
              });
            }
          }
        }

        // Mario vs Bullet Bills
        for (let i = bulletBills.length - 1; i >= 0; i--) {
          const bullet = bulletBills[i];
          if (bullet.alive && checkCollision(mario, bullet)) {
            // Check if Mario jumped on the Bullet Bill
            if (mario.velocityY > 0 && mario.y < bullet.y) {
              // Defeated Bullet Bill by jumping on it
              bullet.alive = false;
              bulletBills.splice(i, 1);
              mario.velocityY = JUMP_FORCE * 0.5; // Small bounce
              score += 200; // More points for defeating Bullet Bill
              playEnemyDefeatSound();

              // Add explosion particles
              for (let j = 0; j < 10; j++) {
                particles.push({
                  x: bullet.x + bullet.width / 2,
                  y: bullet.y + bullet.height / 2,
                  velocityX: (Math.random() - 0.5) * 6,
                  velocityY: (Math.random() - 0.5) * 6,
                  life: 30,
                  color: Math.random() < 0.5 ? "#FF4500" : "#FFD700",
                  size: 4 + Math.random() * 4,
                });
              }
            } else {
              // Hit by Bullet Bill
              loseLife();
              bullet.alive = false;
              bulletBills.splice(i, 1);

              // Add explosion particles
              for (let j = 0; j < 8; j++) {
                particles.push({
                  x: bullet.x + bullet.width / 2,
                  y: bullet.y + bullet.height / 2,
                  velocityX: (Math.random() - 0.5) * 5,
                  velocityY: (Math.random() - 0.5) * 5,
                  life: 25,
                  color: "#FF0000",
                  size: 3 + Math.random() * 3,
                });
              }
            }
          }
        }

        // Mario vs power-ups
        for (
          let powerUpIndex = powerUps.length - 1;
          powerUpIndex >= 0;
          powerUpIndex--
        ) {
          const powerUp = powerUps[powerUpIndex];
          if (checkCollision(mario, powerUp)) {
            powerUps.splice(powerUpIndex, 1);

            if (powerUp.type === "mushroom") {
              mario.powerLevel = Math.min(mario.powerLevel + 1, 2);
              score += 1000;
              playPowerUpSound();
            } else if (powerUp.type === "fireflower") {
              mario.powerLevel = 2;
              score += 1000;
              playPowerUpSound();
            }
            break; // Only collect one power-up per frame to prevent issues
          }
        }
      }

      // Collision detection helper
      function checkCollision(obj1, obj2) {
        return (
          obj1.x < obj2.x + obj2.width &&
          obj1.x + obj1.width > obj2.x &&
          obj1.y < obj2.y + obj2.height &&
          obj1.y + obj1.height > obj2.y
        );
      }

      // Lose a life
      function loseLife() {
        lives--;
        document.getElementById("lives").textContent = lives;

        if (lives <= 0) {
          gameOver();
        } else {
          // Reset Mario position
          mario.x = 50; // Updated to match new starting position
          mario.y = GROUND_LEVEL - 32;
          mario.velocityX = 0;
          mario.velocityY = 0;
        }
      }

      // Game over
      function gameOver() {
        gameRunning = false;
        stopBackgroundMusic();
        playGameOverSound();
        document.getElementById("final-score").textContent = score;
        document.getElementById("game-over").style.display = "block";

        // Hide touch controls when game over
        const touchControls = document.getElementById("touch-controls");
        if (touchControls) {
          touchControls.style.display = "none";
        }
      }

      // Restart game
      function restartGame() {
        location.reload();
      }

      // Touch controls setup
      function setupTouchControls() {
        const leftButton = document.getElementById("left-button");
        const rightButton = document.getElementById("right-button");
        const jumpButton = document.getElementById("jump-button");

        // Touch/mouse events for left movement
        leftButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["ArrowLeft"] = true;
          keys["KeyA"] = true;
        });
        leftButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["ArrowLeft"] = false;
          keys["KeyA"] = false;
        });
        leftButton.addEventListener("mousedown", () => {
          keys["ArrowLeft"] = true;
          keys["KeyA"] = true;
        });
        leftButton.addEventListener("mouseup", () => {
          keys["ArrowLeft"] = false;
          keys["KeyA"] = false;
        });

        // Touch/mouse events for right movement
        rightButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["ArrowRight"] = true;
          keys["KeyD"] = true;
        });
        rightButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["ArrowRight"] = false;
          keys["KeyD"] = false;
        });
        rightButton.addEventListener("mousedown", () => {
          keys["ArrowRight"] = true;
          keys["KeyD"] = true;
        });
        rightButton.addEventListener("mouseup", () => {
          keys["ArrowRight"] = false;
          keys["KeyD"] = false;
        });

        // Touch/mouse events for jump
        jumpButton.addEventListener("touchstart", (e) => {
          e.preventDefault();
          keys["Space"] = true;
          keys["ArrowUp"] = true;
          keys["KeyW"] = true;
        });
        jumpButton.addEventListener("touchend", (e) => {
          e.preventDefault();
          keys["Space"] = false;
          keys["ArrowUp"] = false;
          keys["KeyW"] = false;
        });
        jumpButton.addEventListener("mousedown", () => {
          keys["Space"] = true;
          keys["ArrowUp"] = true;
          keys["KeyW"] = true;
        });
        jumpButton.addEventListener("mouseup", () => {
          keys["Space"] = false;
          keys["ArrowUp"] = false;
          keys["KeyW"] = false;
        });

        // Prevent default touch behaviors on buttons
        [leftButton, rightButton, jumpButton].forEach((button) => {
          button.addEventListener("touchstart", (e) => e.preventDefault(), {
            passive: false,
          });
          button.addEventListener("touchmove", (e) => e.preventDefault(), {
            passive: false,
          });
          button.addEventListener("touchend", (e) => e.preventDefault(), {
            passive: false,
          });
        });
      }

      // Audio enable overlay
      function hideAudioOverlay() {
        const overlay = document.getElementById("audio-overlay");
        if (overlay) {
          overlay.style.display = "none";
        }
      }

      // Make sure audio works on user interaction (required by browsers)
      let audioStarted = false;

      function enableAudio() {
        if (audioContext && audioContext.state === "suspended") {
          audioContext.resume();
        }
        // Start background music on first user interaction
        if (!audioStarted) {
          // Initialize enemies based on selected difficulty
          initializeEnemies();
          // Initialize initial obstacles
          initializeObstacles();
          // Initialize Bill Blasters
          initializeBillBlasters();
          startBackgroundMusic();
          audioStarted = true;
          hideAudioOverlay();

          // Show touch controls when game starts
          const touchControls = document.getElementById("touch-controls");
          if (touchControls) {
            touchControls.style.display = "flex";
          }
        }
      }

      // Initialize obstacles based on difficulty
      function initializeObstacles() {
        const difficulty = getDifficulty();
        obstacles = [];
        fallingRocks = [];

        // Initialize lava hazards
        initializeLava();

        // Add some initial spikes based on difficulty
        if (selectedDifficulty !== "easy") {
          // Add spikes at various positions
          const spikePositions = [450, 800, 1150];
          spikePositions.forEach((pos, idx) => {
            if (idx < (selectedDifficulty === "hard" ? 3 : 1)) {
              obstacles.push({
                x: pos,
                y: GROUND_LEVEL - 20,
                width: 24,
                height: 20,
                type: "spike",
              });
            }
          });
        }

        // Update UI to show current difficulty
        const difficultyLabels = {
          easy: "üå± Easy",
          medium: "‚ö° Medium",
          hard: "üî• Hard",
        };
        const diffDisplay = document.getElementById("current-difficulty");
        if (diffDisplay) {
          diffDisplay.textContent = difficultyLabels[selectedDifficulty];
        }
      }

      // Initialize Bill Blasters based on difficulty
      function initializeBillBlasters() {
        const difficulty = getDifficulty();
        billBlasters = [];
        bulletBills = [];

        // Add initial Bill Blasters based on difficulty
        const blasterPositions = [
          { x: 850, y: GROUND_LEVEL - 200 },
          { x: 1100, y: 200 },
        ];

        // Spawn initial blasters based on difficulty
        // Easy: No rockets at all
        // Medium: 0 initial blasters (reduced from 1)
        // Hard: 1 initial blaster (reduced from 2)
        const blasterCount =
          selectedDifficulty === "easy"
            ? 0
            : selectedDifficulty === "medium"
            ? 0
            : 1;

        for (let i = 0; i < blasterCount; i++) {
          const pos = blasterPositions[i];
          billBlasters.push({
            x: pos.x,
            y: pos.y,
            width: 48,
            height: 48,
            type: "blaster",
            shootTimer: 120 + Math.random() * 60,
            shootCooldown: selectedDifficulty === "hard" ? 180 : 300,
          });
        }
      }

      document.addEventListener("click", enableAudio);

      // Also handle the enable audio button specifically
      document.addEventListener("DOMContentLoaded", () => {
        const enableBtn = document.getElementById("enable-audio-btn");
        if (enableBtn) {
          enableBtn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent double triggering
            enableAudio();
          });
        }

        // Handle song selection
        document.querySelectorAll(".song-option").forEach((option) => {
          option.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent triggering enableAudio
            const index = parseInt(option.getAttribute("data-index"));
            selectSong(index);
          });
        });

        // Handle difficulty selection
        document.querySelectorAll(".difficulty-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent triggering enableAudio
            const difficulty = btn.getAttribute("data-difficulty");
            selectDifficulty(difficulty);
          });
        });

        // Handle character selection
        document.querySelectorAll(".character-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent triggering enableAudio
            const character = btn.getAttribute("data-character");
            selectCharacter(character);
          });
        });

        // Initialize song selection display
        updateSongSelection();
        updateDifficultySelection();
        updateCharacterSelection();

        // Draw character previews
        drawCharacterPreviews();
      });

      // Function to select difficulty
      function selectDifficulty(difficulty) {
        if (difficultyConfig[difficulty]) {
          selectedDifficulty = difficulty;
          updateDifficultySelection();
        }
      }

      function updateDifficultySelection() {
        // Remove selected class from all options
        document.querySelectorAll(".difficulty-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });
        // Add selected class to current selection
        const selectedBtn = document.querySelector(
          `.difficulty-btn[data-difficulty="${selectedDifficulty}"]`
        );
        if (selectedBtn) {
          selectedBtn.classList.add("selected");
        }
        // Update description
        const infoEl = document.getElementById("difficulty-info");
        if (infoEl) {
          infoEl.textContent = getDifficulty().description;
        }
      }

      // Function to select character
      function selectCharacter(character) {
        const validCharacters = ["mario", "luigi", "peach", "toad", "bowser"];
        if (validCharacters.includes(character)) {
          selectedCharacter = character;
          updateCharacterSelection();
        }
      }

      function updateCharacterSelection() {
        // Remove selected class from all options
        document.querySelectorAll(".character-btn").forEach((btn) => {
          btn.classList.remove("selected");
        });
        // Add selected class to current selection
        const selectedBtn = document.querySelector(
          `.character-btn[data-character="${selectedCharacter}"]`
        );
        if (selectedBtn) {
          selectedBtn.classList.add("selected");
        }
      }

      // Draw character previews on canvases
      function drawCharacterPreviews() {
        // Helper function to draw a character on a given canvas
        function drawCharacterOnCanvas(canvasId, characterType) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return;

          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, 48, 48);

          // Scale and position for preview
          const x = 8;
          const y = 8;
          const scale = 1; // Keep 32px character size in 48px canvas

          // Draw based on character type
          switch (characterType) {
            case "mario":
              drawMarioPreview(ctx, x, y);
              break;
            case "luigi":
              drawLuigiPreview(ctx, x, y);
              break;
            case "peach":
              drawPeachPreview(ctx, x, y);
              break;
            case "toad":
              drawToadPreview(ctx, x, y);
              break;
            case "bowser":
              drawBowserPreview(ctx, x, y);
              break;
          }
        }

        // Draw each character preview
        drawCharacterOnCanvas("preview-mario", "mario");
        drawCharacterOnCanvas("preview-luigi", "luigi");
        drawCharacterOnCanvas("preview-peach", "peach");
        drawCharacterOnCanvas("preview-toad", "toad");
        drawCharacterOnCanvas("preview-bowser", "bowser");
      }

      // Preview drawing functions (simplified versions)
      function drawMarioPreview(ctx, x, y) {
        // Overalls (blue)
        ctx.fillStyle = "#0000FF";
        ctx.fillRect(x + 6, y + 16, 20, 16);

        // Shirt (red)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + 6, y + 8, 20, 8);

        // Skin (peach)
        ctx.fillStyle = "#FFB366";
        ctx.fillRect(x + 8, y + 4, 16, 12);

        // Hat (red)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + 6, y - 2, 20, 8);
        ctx.fillStyle = "#FFF";
        ctx.font = "bold 6px Arial";
        ctx.fillText("M", x + 14, y + 4);

        // Eyes
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + 10, y + 6, 3, 3);
        ctx.fillRect(x + 19, y + 6, 3, 3);

        // Mustache
        ctx.fillRect(x + 12, y + 12, 8, 2);

        // Buttons
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 14, y + 20, 4, 4);

        // Gloves
        ctx.fillStyle = "#FFF";
        ctx.fillRect(x + 2, y + 16, 6, 8);
        ctx.fillRect(x + 24, y + 16, 6, 8);

        // Shoes
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + 4, y + 28, 8, 4);
        ctx.fillRect(x + 20, y + 28, 8, 4);
      }

      function drawLuigiPreview(ctx, x, y) {
        // Overalls (green)
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(x + 6, y + 16, 20, 16);

        // Shirt (green)
        ctx.fillStyle = "#00DD00";
        ctx.fillRect(x + 6, y + 8, 20, 8);

        // Skin
        ctx.fillStyle = "#FFB366";
        ctx.fillRect(x + 8, y + 4, 16, 12);

        // Hat (green)
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(x + 6, y - 2, 20, 8);
        ctx.fillStyle = "#FFF";
        ctx.font = "bold 6px Arial";
        ctx.fillText("L", x + 14, y + 4);

        // Eyes
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + 10, y + 6, 3, 3);
        ctx.fillRect(x + 19, y + 6, 3, 3);

        // Mustache
        ctx.fillRect(x + 12, y + 12, 8, 2);

        // Buttons
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 14, y + 20, 4, 4);

        // Gloves
        ctx.fillStyle = "#FFF";
        ctx.fillRect(x + 2, y + 16, 6, 8);
        ctx.fillRect(x + 24, y + 16, 6, 8);

        // Shoes
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + 4, y + 28, 8, 4);
        ctx.fillRect(x + 20, y + 28, 8, 4);
      }

      function drawPeachPreview(ctx, x, y) {
        // Dress (pink)
        ctx.fillStyle = "#FFB3D9";
        ctx.fillRect(x + 4, y + 14, 24, 18);

        // Dress top
        ctx.fillStyle = "#FFC0E0";
        ctx.fillRect(x + 6, y + 8, 20, 8);

        // Skin
        ctx.fillStyle = "#FFCCAA";
        ctx.fillRect(x + 8, y + 4, 16, 12);

        // Hair (blonde)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 6, y - 2, 20, 8);
        ctx.fillRect(x + 4, y + 2, 24, 6);

        // Crown
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 10, y - 4, 12, 4);
        ctx.fillStyle = "#FF69B4";
        ctx.fillRect(x + 12, y - 6, 2, 2);
        ctx.fillRect(x + 16, y - 6, 2, 2);
        ctx.fillRect(x + 20, y - 6, 2, 2);

        // Eyes (blue)
        ctx.fillStyle = "#0066FF";
        ctx.fillRect(x + 10, y + 6, 3, 3);
        ctx.fillRect(x + 19, y + 6, 3, 3);

        // Smile
        ctx.fillStyle = "#FF69B4";
        ctx.fillRect(x + 12, y + 12, 8, 2);

        // Earrings
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(x + 7, y + 8, 2, 3);
        ctx.fillRect(x + 23, y + 8, 2, 3);

        // Gloves
        ctx.fillStyle = "#FFF";
        ctx.fillRect(x + 2, y + 16, 6, 8);
        ctx.fillRect(x + 24, y + 16, 6, 8);

        // Shoes (red heels)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + 4, y + 28, 8, 4);
        ctx.fillRect(x + 20, y + 28, 8, 4);
      }

      function drawToadPreview(ctx, x, y) {
        // Vest (blue)
        ctx.fillStyle = "#0066CC";
        ctx.fillRect(x + 6, y + 16, 20, 16);

        // Body (white)
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + 8, y + 8, 16, 16);

        // Head
        ctx.fillStyle = "#FFE4C4";
        ctx.fillRect(x + 6, y, 20, 16);

        // Mushroom cap (red)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + 4, y - 4, 24, 12);

        // White spots
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + 8, y - 2, 4, 4);
        ctx.fillRect(x + 16, y - 2, 4, 4);
        ctx.fillRect(x + 12, y + 2, 4, 4);
        ctx.fillRect(x + 20, y + 2, 4, 4);

        // Eyes
        ctx.fillStyle = "#000000";
        ctx.fillRect(x + 10, y + 6, 4, 4);
        ctx.fillRect(x + 18, y + 6, 4, 4);

        // Smile
        ctx.fillRect(x + 12, y + 12, 8, 2);

        // Button
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 14, y + 20, 4, 4);

        // Arms
        ctx.fillStyle = "#FFE4C4";
        ctx.fillRect(x + 2, y + 16, 6, 8);
        ctx.fillRect(x + 24, y + 16, 6, 8);

        // Shoes
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x + 6, y + 28, 8, 4);
        ctx.fillRect(x + 18, y + 28, 8, 4);
      }

      function drawBowserPreview(ctx, x, y) {
        // Body (orange/red)
        ctx.fillStyle = "#FF6600";
        ctx.fillRect(x + 6, y + 12, 20, 20);

        // Shell spikes
        ctx.fillStyle = "#FFD700";
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(x + 10 + i * 6, y + 8, 4, 6);
        }

        // Head
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(x + 6, y, 20, 16);

        // Horns
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 4, y - 2, 4, 6);
        ctx.fillRect(x + 24, y - 2, 4, 6);

        // Eyes (yellow with red pupils)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + 10, y + 4, 4, 4);
        ctx.fillRect(x + 18, y + 4, 4, 4);
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + 11, y + 5, 2, 2);
        ctx.fillRect(x + 19, y + 5, 2, 2);

        // Eyebrows (angry)
        ctx.fillStyle = "#CC4400";
        ctx.fillRect(x + 8, y + 2, 6, 2);
        ctx.fillRect(x + 18, y + 2, 6, 2);

        // Snout
        ctx.fillStyle = "#FFAA66";
        ctx.fillRect(x + 10, y + 10, 12, 6);

        // Fangs
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + 12, y + 14, 2, 3);
        ctx.fillRect(x + 18, y + 14, 2, 3);

        // Arms
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(x + 2, y + 14, 6, 8);
        ctx.fillRect(x + 24, y + 14, 6, 8);

        // Feet
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(x + 4, y + 28, 8, 4);
        ctx.fillRect(x + 20, y + 28, 8, 4);
      }

      // Update timer
      function updateTimer() {
        if (!gameRunning) return;

        timeLeft--;
        document.getElementById("time").textContent = timeLeft;

        if (timeLeft <= 0) {
          gameOver();
        }
      }

      // Render everything
      function render() {
        // Clear canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        if (insideCastle) {
          // Draw castle interior
          drawCastleInterior();

          // Draw projectiles
          projectiles.forEach((projectile) => {
            drawProjectile(projectile);
          });

          // Draw interior boss
          if (interiorBoss && interiorBoss.alive) {
            drawInteriorBoss(interiorBoss);
          }

          // Draw particles
          particles.forEach((particle) => {
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = particle.life / 30;
            ctx.fillRect(
              particle.x - particle.size / 2,
              particle.y - particle.size / 2,
              particle.size,
              particle.size
            );
            ctx.globalAlpha = 1;
          });

          // Draw Player
          drawPlayer();

          // Update UI
          document.getElementById("score").textContent = score;

          // Show boss health inside castle
          if (interiorBoss && interiorBoss.alive) {
            document.getElementById("boss-health-value").textContent =
              interiorBoss.health;
            document.getElementById("boss-health").style.display = "block";
          } else if (interiorBoss && !interiorBoss.alive) {
            document.getElementById("boss-health").style.display = "none";
            // Show exit prompt
            ctx.fillStyle = "#FFD700";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Press E to Exit Castle", CANVAS_WIDTH / 2, 50);
          }

          return; // Skip outdoor rendering
        }

        // OUTDOOR RENDERING
        // Draw background (doesn't move with camera)
        ctx.fillStyle = "#87ceeb";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw clouds (parallax effect - move slowly with camera)
        ctx.save();
        ctx.translate(-cameraX * 0.5, 0);
        drawClouds();
        ctx.restore();

        // Draw all world objects with camera offset
        ctx.save();
        ctx.translate(-cameraX, 0);

        // Draw Bowser's Castle (background structure)
        drawCastle();

        // Draw platforms
        platforms.forEach((platform) => {
          drawPlatform(platform);
        });

        // Draw enemies
        enemies.forEach((enemy) => {
          if (enemy.alive) {
            drawEnemy(enemy);
          }
        });

        // Draw power-ups
        powerUps.forEach((powerUp) => {
          drawPowerUp(powerUp);
        });

        // Draw lava hazards
        lavaHazards.forEach((lava) => {
          // Animated lava effect
          const time = Date.now() * 0.005;
          const alpha = 0.8 + Math.sin(time + lava.x * 0.01) * 0.2;

          // Main lava body
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = alpha;
          ctx.fillRect(lava.x, lava.y, lava.width, lava.height);

          // Lava highlights
          ctx.fillStyle = "#FFD700";
          ctx.globalAlpha = alpha * 0.6;
          ctx.fillRect(lava.x + 2, lava.y + 2, lava.width - 4, 4);

          // Lava bubbles
          ctx.fillStyle = "#FF6347";
          ctx.globalAlpha = alpha * 0.4;
          for (let i = 0; i < 5; i++) {
            const bubbleX = lava.x + 10 + i * 15 + Math.sin(time + i) * 3;
            const bubbleY = lava.y + 5 + Math.sin(time * 2 + i) * 2;
            ctx.fillRect(bubbleX, bubbleY, 3, 3);
          }

          ctx.globalAlpha = 1;
        });

        // Draw obstacles (spikes)
        obstacles.forEach((obstacle) => {
          if (obstacle.type === "spike") {
            drawSpike(obstacle);
          }
        });

        // Draw falling rocks
        fallingRocks.forEach((rock) => {
          drawFallingRock(rock);
        });

        // Draw Bill Blasters (cannons)
        billBlasters.forEach((blaster) => {
          drawBillBlaster(blaster);
        });

        // Draw Bullet Bills
        bulletBills.forEach((bullet) => {
          if (bullet.alive) {
            drawBulletBill(bullet);
          }
        });

        // Draw particles
        particles.forEach((particle) => {
          ctx.fillStyle = particle.color;
          ctx.globalAlpha = particle.life / 30;
          ctx.fillRect(
            particle.x - particle.size / 2,
            particle.y - particle.size / 2,
            particle.size,
            particle.size
          );
          ctx.globalAlpha = 1;
        });

        // Draw Player (selected character)
        drawPlayer();

        ctx.restore();

        // Update UI
        document.getElementById("score").textContent = score;

        // Show boss warning and health when boss area is near
        const boss = enemies.find((e) => e.type === "bowser" && e.alive);
        if (boss) {
          // Show castle warning when approaching (castle is at x: 2400, boss at x: 2550)
          if (mario.x > 1800 && mario.x < castle.x - 100) {
            document.getElementById("boss-warning").style.display = "block";
          } else if (mario.x > castle.x - 100) {
            document.getElementById("boss-warning").style.display = "none";
            document.getElementById("boss-health").style.display = "block";
          }
        }

        // Show entrance prompt when near castle entrance
        if (showEnterPrompt) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(CANVAS_WIDTH / 2 - 150, 40, 300, 50);
          ctx.fillStyle = "#FFD700";
          ctx.font = "bold 18px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Press E to Enter Castle", CANVAS_WIDTH / 2, 70);
        }
      }

      // Draw clouds
      function drawClouds() {
        ctx.fillStyle = "white";
        // Simple cloud shapes
        for (let i = 0; i < 5; i++) {
          const x = i * 200 + 50;
          const y = 100 + Math.sin(i) * 20;
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.arc(x + 25, y, 25, 0, Math.PI * 2);
          ctx.arc(x + 50, y, 20, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Draw Bowser's Castle
      function drawCastle() {
        const castleX = castle.x;
        const castleY = castle.y;
        const castleWidth = castle.width;
        const castleHeight = castle.height;

        // Main castle body - dark stone gray
        ctx.fillStyle = "#4A4A4A";
        ctx.fillRect(castleX, castleY, castleWidth, castleHeight);

        // Castle wall pattern - darker stones
        ctx.strokeStyle = "#2F2F2F";
        ctx.lineWidth = 2;
        for (let row = 0; row < 10; row++) {
          for (let col = 0; col < 8; col++) {
            const x = castleX + col * 50;
            const y = castleY + row * 30;
            ctx.strokeRect(x, y, 50, 30);
          }
        }

        // Draw towers
        castle.towers.forEach((tower, index) => {
          // Tower body - slightly lighter gray
          ctx.fillStyle = "#555555";
          ctx.fillRect(tower.x, tower.y, tower.width, tower.height);

          // Tower stone pattern
          ctx.strokeStyle = "#333333";
          ctx.lineWidth = 2;
          for (let row = 0; row < 12; row++) {
            ctx.strokeRect(tower.x, tower.y + row * 30, tower.width, 30);
          }

          // Tower battlements (castle top decorations)
          ctx.fillStyle = "#666666";
          for (let i = 0; i < 4; i++) {
            ctx.fillRect(tower.x + i * 20, tower.y - 10, 15, 10);
          }

          // Windows - glowing red (ominous)
          ctx.fillStyle = "#8B0000";
          const windowY1 = tower.y + 50;
          const windowY2 = tower.y + 120;
          const windowY3 = tower.y + 190;
          const windowX = tower.x + tower.width / 2 - 12;

          ctx.fillRect(windowX, windowY1, 24, 30);
          ctx.fillRect(windowX, windowY2, 24, 30);
          ctx.fillRect(windowX, windowY3, 24, 30);

          // Window glow effect
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = 0.5;
          ctx.fillRect(windowX + 2, windowY1 + 2, 20, 26);
          ctx.fillRect(windowX + 2, windowY2 + 2, 20, 26);
          ctx.fillRect(windowX + 2, windowY3 + 2, 20, 26);
          ctx.globalAlpha = 1;

          // Window bars
          ctx.fillStyle = "#000000";
          ctx.fillRect(windowX + 10, windowY1, 4, 30);
          ctx.fillRect(windowX + 10, windowY2, 4, 30);
          ctx.fillRect(windowX + 10, windowY3, 4, 30);
        });

        // Main castle entrance - large dark archway
        const entranceWidth = 100;
        const entranceHeight = 120;
        const entranceX = castleX + castleWidth / 2 - entranceWidth / 2;
        const entranceY = castleY + castleHeight - entranceHeight;

        // Archway background - very dark
        ctx.fillStyle = "#1A1A1A";
        ctx.fillRect(entranceX, entranceY, entranceWidth, entranceHeight);

        // Archway top (semi-circle effect with rectangles)
        ctx.fillRect(entranceX + 10, entranceY - 10, 80, 10);
        ctx.fillRect(entranceX + 20, entranceY - 20, 60, 10);
        ctx.fillRect(entranceX + 30, entranceY - 25, 40, 10);

        // Entrance border - dark stone
        ctx.strokeStyle = "#2F2F2F";
        ctx.lineWidth = 4;
        ctx.strokeRect(entranceX, entranceY, entranceWidth, entranceHeight);

        // Portcullis (gate) - partially lowered
        ctx.fillStyle = "#3A3A3A";
        const gateY = entranceY + 40;
        for (let i = 0; i < 8; i++) {
          ctx.fillRect(entranceX + 10 + i * 10, gateY, 6, 80);
        }
        // Horizontal bars
        for (let i = 0; i < 5; i++) {
          ctx.fillRect(entranceX + 10, gateY + i * 16, 80, 4);
        }

        // Castle flags on towers
        castle.flags.forEach((flag, index) => {
          // Flag pole
          ctx.fillStyle = "#2F2F2F";
          ctx.fillRect(flag.x, flag.y, 4, 60);

          // Flag - Bowser's flag (black with red/orange)
          const flagWave = Math.sin(Date.now() * 0.003 + index) * 3;
          ctx.fillStyle = "#000000";
          ctx.fillRect(flag.x + 4, flag.y + 5, 30 + flagWave, 20);

          // Bowser emblem on flag (simplified - red/orange design)
          ctx.fillStyle = "#FF4500";
          ctx.fillRect(flag.x + 10, flag.y + 10, 12, 10);
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(flag.x + 14, flag.y + 12, 4, 6);
        });

        // Add some dark clouds/smoke around castle for atmosphere
        ctx.fillStyle = "rgba(50, 50, 50, 0.3)";
        ctx.beginPath();
        ctx.arc(castleX + 100, castleY - 20, 40, 0, Math.PI * 2);
        ctx.arc(castleX + 150, castleY - 30, 50, 0, Math.PI * 2);
        ctx.arc(castleX + 250, castleY - 20, 40, 0, Math.PI * 2);
        ctx.arc(castleX + 300, castleY - 25, 45, 0, Math.PI * 2);
        ctx.fill();

        // Lava moat in front of castle (optional dramatic effect)
        const moatY = GROUND_LEVEL - 15;
        const moatX = castleX - 50;
        ctx.fillStyle = "#FF4500";
        const lavaAlpha = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
        ctx.globalAlpha = lavaAlpha;
        ctx.fillRect(moatX, moatY, castleWidth + 100, 25);

        // Lava highlights
        ctx.fillStyle = "#FFD700";
        ctx.globalAlpha = lavaAlpha * 0.6;
        ctx.fillRect(moatX + 5, moatY + 3, castleWidth + 90, 6);
        ctx.globalAlpha = 1;
      }

      // Draw castle interior
      function drawCastleInterior() {
        // Dark throne room background
        ctx.fillStyle = "#1A1A1A";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Stone floor
        ctx.fillStyle = "#2F2F2F";
        ctx.fillRect(
          0,
          GROUND_LEVEL,
          CANVAS_WIDTH,
          CANVAS_HEIGHT - GROUND_LEVEL
        );

        // Floor tiles
        ctx.strokeStyle = "#1A1A1A";
        ctx.lineWidth = 2;
        for (let i = 0; i < CANVAS_WIDTH / 50; i++) {
          for (let j = 0; j < 5; j++) {
            ctx.strokeRect(i * 50, GROUND_LEVEL + j * 50, 50, 50);
          }
        }

        // Wall torches (flickering light)
        const flicker = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
        const torchPositions = [100, 300, 500, 700];
        torchPositions.forEach((x) => {
          // Torch holder
          ctx.fillStyle = "#4A4A4A";
          ctx.fillRect(x - 5, 150, 10, 40);

          // Flame
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = flicker;
          ctx.fillRect(x - 8, 140, 16, 12);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(x - 5, 142, 10, 8);
          ctx.globalAlpha = 1;

          // Glow
          const gradient = ctx.createRadialGradient(x, 145, 0, x, 145, 60);
          gradient.addColorStop(0, "rgba(255, 100, 0, 0.3)");
          gradient.addColorStop(1, "rgba(255, 100, 0, 0)");
          ctx.fillStyle = gradient;
          ctx.globalAlpha = flicker * 0.5;
          ctx.fillRect(x - 60, 85, 120, 120);
          ctx.globalAlpha = 1;
        });

        // Pillars
        const pillarX = [50, CANVAS_WIDTH - 100];
        pillarX.forEach((x) => {
          ctx.fillStyle = "#3A3A3A";
          ctx.fillRect(x, 200, 50, GROUND_LEVEL - 200);

          // Pillar details
          ctx.strokeStyle = "#2A2A2A";
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.strokeRect(x, 200 + i * 80, 50, 80);
          }
        });

        // Throne at the back
        const throneX = CANVAS_WIDTH - 150;
        const throneY = GROUND_LEVEL - 60;
        ctx.fillStyle = "#4A4A4A";
        // Throne base
        ctx.fillRect(throneX, throneY + 40, 60, 20);
        // Throne back
        ctx.fillRect(throneX + 10, throneY, 40, 50);
        // Throne spikes
        ctx.fillStyle = "#FFD700";
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(throneX + 15 + i * 10, throneY - 10, 5, 10);
        }

        // Ominous text at top
        ctx.fillStyle = "#8B0000";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("BOWSER'S THRONE ROOM", CANVAS_WIDTH / 2, 40);

        // Boss health bar
        if (interiorBoss && interiorBoss.alive) {
          const maxHealth =
            selectedDifficulty === "easy"
              ? 5
              : selectedDifficulty === "medium"
              ? 8
              : 12;
          const healthPercent = interiorBoss.health / maxHealth;

          ctx.fillStyle = "#333";
          ctx.fillRect(CANVAS_WIDTH / 2 - 150, 60, 300, 20);
          ctx.fillStyle =
            healthPercent > 0.5
              ? "#00FF00"
              : healthPercent > 0.25
              ? "#FFD700"
              : "#FF0000";
          ctx.fillRect(CANVAS_WIDTH / 2 - 148, 62, 296 * healthPercent, 16);
          ctx.strokeStyle = "#FFF";
          ctx.lineWidth = 2;
          ctx.strokeRect(CANVAS_WIDTH / 2 - 150, 60, 300, 20);
        }

        // Controls hint
        ctx.fillStyle = "#AAAAAA";
        ctx.font = "14px Arial";
        ctx.textAlign = "left";
        ctx.fillText(
          "Controls: A/D = Move  |  F/Shift = Shoot",
          10,
          CANVAS_HEIGHT - 10
        );
      }

      // Draw projectile
      function drawProjectile(projectile) {
        if (projectile.enemy) {
          // Enemy fireball - red/orange
          const time = Date.now() * 0.02;
          const flameSize = 4 + Math.sin(time) * 2;
          ctx.fillStyle = "#FF4500";
          ctx.fillRect(
            projectile.x,
            projectile.y,
            projectile.width,
            projectile.height
          );
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(
            projectile.x + 4,
            projectile.y + 4,
            projectile.width - 8,
            projectile.height - 8
          );

          // Flame trail
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = 0.5;
          ctx.fillRect(
            projectile.x - flameSize,
            projectile.y + projectile.height / 2 - flameSize / 2,
            flameSize,
            flameSize
          );
          ctx.globalAlpha = 1;
        } else {
          // Player punch/energy blast - blue/white
          ctx.fillStyle = "#0066FF";
          ctx.fillRect(
            projectile.x,
            projectile.y,
            projectile.width,
            projectile.height
          );
          ctx.fillStyle = "#87CEEB";
          ctx.fillRect(
            projectile.x + 3,
            projectile.y + 3,
            projectile.width - 6,
            projectile.height - 6
          );
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(
            projectile.x + 6,
            projectile.y + 6,
            projectile.width - 12,
            projectile.height - 12
          );

          // Glow effect
          ctx.strokeStyle = "#87CEEB";
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;
          ctx.strokeRect(
            projectile.x - 2,
            projectile.y - 2,
            projectile.width + 4,
            projectile.height + 4
          );
          ctx.globalAlpha = 1;
        }
      }

      // Draw interior boss
      function drawInteriorBoss(boss) {
        // Giant Bowser - more menacing interior version
        const x = boss.x;
        const y = boss.y;
        const w = boss.width;
        const h = boss.height;

        // Body - dark red
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(x + w * 0.1, y + h * 0.3, w * 0.8, h * 0.5);

        // Shell with spikes
        ctx.fillStyle = "#654321";
        ctx.fillRect(x + w * 0.15, y + h * 0.2, w * 0.7, h * 0.3);
        // Spikes
        ctx.fillStyle = "#DC143C";
        for (let i = 0; i < 7; i++) {
          ctx.fillRect(
            x + w * 0.2 + i * w * 0.1,
            y + h * 0.15,
            w * 0.05,
            h * 0.1
          );
        }

        // Head - large and menacing
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(x + w * 0.2, y, w * 0.6, h * 0.3);

        // Horns - golden yellow
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x + w * 0.15, y - h * 0.05, w * 0.08, h * 0.1);
        ctx.fillRect(x + w * 0.77, y - h * 0.05, w * 0.08, h * 0.1);

        // Eyes - glowing red (menacing)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(x + w * 0.3, y + h * 0.08, w * 0.08, h * 0.08);
        ctx.fillRect(x + w * 0.62, y + h * 0.08, w * 0.08, h * 0.08);
        ctx.fillStyle = "#FFFF00";
        ctx.globalAlpha = 0.7;
        ctx.fillRect(x + w * 0.32, y + h * 0.1, w * 0.04, h * 0.04);
        ctx.fillRect(x + w * 0.64, y + h * 0.1, w * 0.04, h * 0.04);
        ctx.globalAlpha = 1;

        // Angry eyebrows
        ctx.fillStyle = "#000000";
        ctx.fillRect(x + w * 0.28, y + h * 0.03, w * 0.12, h * 0.03);
        ctx.fillRect(x + w * 0.6, y + h * 0.03, w * 0.12, h * 0.03);

        // Fangs - white and sharp
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + w * 0.35, y + h * 0.2, w * 0.05, h * 0.08);
        ctx.fillRect(x + w * 0.6, y + h * 0.2, w * 0.05, h * 0.08);

        // Arms
        ctx.fillStyle = "#8B0000";
        ctx.fillRect(x, y + h * 0.25, w * 0.15, h * 0.1);
        ctx.fillRect(x + w * 0.85, y + h * 0.25, w * 0.15, h * 0.1);

        // Legs
        ctx.fillRect(x + w * 0.15, y + h * 0.7, w * 0.15, h * 0.1);
        ctx.fillRect(x + w * 0.7, y + h * 0.7, w * 0.15, h * 0.1);

        // Claws - black
        ctx.fillStyle = "#000000";
        ctx.fillRect(x - w * 0.02, y + h * 0.3, w * 0.05, h * 0.05);
        ctx.fillRect(x + w * 0.97, y + h * 0.3, w * 0.05, h * 0.05);

        // Fire breath indicator when attacking
        if (boss.attackTimer > 80) {
          ctx.fillStyle = "#FF4500";
          ctx.globalAlpha = 0.7;
          const breathSize = (90 - boss.attackTimer) * 3;
          ctx.fillRect(x + w * 0.45, y + h * 0.22, breathSize, h * 0.08);
          ctx.globalAlpha = 1;
        }
      }

      // Draw platforms
      function drawPlatform(platform) {
        // Add flying effect for flying platforms
        if (platform.flying) {
          // Add a subtle glow/shadow effect
          ctx.save();
          ctx.shadowColor = "rgba(255, 255, 100, 0.5)";
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 2;
        }

        switch (platform.type) {
          case "ground":
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            // Grass on top
            ctx.fillStyle = "#228B22";
            ctx.fillRect(platform.x, platform.y, platform.width, 10);
            break;
          case "platform":
            ctx.fillStyle = "#DEB887";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            break;
          case "brick":
            ctx.fillStyle = platform.breakable ? "#CD853F" : "#696969";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            // Brick pattern
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            break;
          case "question":
            ctx.fillStyle = platform.used ? "#D2B48C" : "#FFD700";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            if (!platform.used) {
              ctx.fillStyle = "#000";
              ctx.font = "20px Arial";
              ctx.textAlign = "center";
              ctx.fillText(
                "?",
                platform.x + platform.width / 2,
                platform.y + platform.height / 2 + 7
              );
            }
            break;
          case "pipe":
            ctx.fillStyle = "#228B22";
            ctx.fillRect(
              platform.x,
              platform.y,
              platform.width,
              platform.height
            );
            ctx.fillStyle = "#000";
            ctx.fillRect(
              platform.x + 5,
              platform.y,
              platform.width - 10,
              platform.height
            );
            break;
        }

        // Restore context for flying platforms
        if (platform.flying) {
          ctx.restore();
        }
      }

      // Draw Player (calls appropriate character drawing function)
      function drawPlayer() {
        switch (selectedCharacter) {
          case "mario":
            drawMario();
            break;
          case "luigi":
            drawLuigi();
            break;
          case "peach":
            drawPeach();
            break;
          case "toad":
            drawToad();
            break;
          case "bowser":
            drawBowserPlayer();
            break;
          default:
            drawMario();
        }
      }

      // Draw Mario
      function drawMario() {
        // Set Mario's size based on power level
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Overalls (blue)
        ctx.fillStyle = "#0000FF";
        ctx.fillRect(
          mario.x + 6,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          20,
          baseHeight - (mario.powerLevel === 0 ? 16 : 24)
        );

        // Shirt (red)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 6, mario.y + 8, 20, baseHeight - 24);

        // Skin (peach)
        ctx.fillStyle = "#FFB366";
        ctx.fillRect(mario.x + 8, mario.y + 4, 16, 12);

        // Hat (red with logo)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 6, mario.y - 2, 20, 8);
        // Hat logo (white M)
        ctx.fillStyle = "#FFF";
        ctx.font = "bold 6px Arial";
        ctx.fillText("M", mario.x + 14, mario.y + 4);

        // Eyes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 10, mario.y + 6, 3, 3);
        ctx.fillRect(mario.x + 19, mario.y + 6, 3, 3);

        // Mustache (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 12, mario.y + 12, 8, 2);

        // Buttons on overalls (yellow)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 20 : 28),
          4,
          4
        );
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 26 : 36),
          4,
          4
        );

        // Gloves (white)
        ctx.fillStyle = "#FFF";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );

        // Shoes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 20, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Mario - add flames
          ctx.fillStyle = "#FF4500";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        // Update Mario's actual size for collision detection
        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw Luigi
      function drawLuigi() {
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Overalls (green instead of blue)
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(
          mario.x + 6,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          20,
          baseHeight - (mario.powerLevel === 0 ? 16 : 24)
        );

        // Shirt (green)
        ctx.fillStyle = "#00DD00";
        ctx.fillRect(mario.x + 6, mario.y + 8, 20, baseHeight - 24);

        // Skin (peach)
        ctx.fillStyle = "#FFB366";
        ctx.fillRect(mario.x + 8, mario.y + 4, 16, 12);

        // Hat (green with logo)
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(mario.x + 6, mario.y - 2, 20, 8);
        // Hat logo (white L)
        ctx.fillStyle = "#FFF";
        ctx.font = "bold 6px Arial";
        ctx.fillText("L", mario.x + 14, mario.y + 4);

        // Eyes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 10, mario.y + 6, 3, 3);
        ctx.fillRect(mario.x + 19, mario.y + 6, 3, 3);

        // Mustache (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 12, mario.y + 12, 8, 2);

        // Buttons on overalls (yellow)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 20 : 28),
          4,
          4
        );
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 26 : 36),
          4,
          4
        );

        // Gloves (white)
        ctx.fillStyle = "#FFF";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );

        // Shoes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 20, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Luigi - green flames
          ctx.fillStyle = "#00FF00";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#ADFF2F";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw Peach
      function drawPeach() {
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Dress (pink)
        ctx.fillStyle = "#FFB3D9";
        ctx.fillRect(
          mario.x + 4,
          mario.y + (mario.powerLevel === 0 ? 14 : 22),
          24,
          baseHeight - (mario.powerLevel === 0 ? 14 : 22)
        );

        // Dress top (lighter pink)
        ctx.fillStyle = "#FFC0E0";
        ctx.fillRect(mario.x + 6, mario.y + 8, 20, baseHeight - 24);

        // Skin (lighter peach)
        ctx.fillStyle = "#FFCCAA";
        ctx.fillRect(mario.x + 8, mario.y + 4, 16, 12);

        // Hair (blonde)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(mario.x + 6, mario.y - 2, 20, 8);
        ctx.fillRect(mario.x + 4, mario.y + 2, 24, 6);

        // Crown (gold)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(mario.x + 10, mario.y - 4, 12, 4);
        ctx.fillStyle = "#FF69B4";
        ctx.fillRect(mario.x + 12, mario.y - 6, 2, 2);
        ctx.fillRect(mario.x + 16, mario.y - 6, 2, 2);
        ctx.fillRect(mario.x + 20, mario.y - 6, 2, 2);

        // Eyes (blue)
        ctx.fillStyle = "#0066FF";
        ctx.fillRect(mario.x + 10, mario.y + 6, 3, 3);
        ctx.fillRect(mario.x + 19, mario.y + 6, 3, 3);

        // Smile
        ctx.fillStyle = "#FF69B4";
        ctx.fillRect(mario.x + 12, mario.y + 12, 8, 2);

        // Earrings (light blue)
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(mario.x + 7, mario.y + 8, 2, 3);
        ctx.fillRect(mario.x + 23, mario.y + 8, 2, 3);

        // Gloves (white)
        ctx.fillStyle = "#FFF";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );

        // Shoes (red heels)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 20, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Peach - pink flames
          ctx.fillStyle = "#FF69B4";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#FFB6C1";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw Toad
      function drawToad() {
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Vest (blue)
        ctx.fillStyle = "#0066CC";
        ctx.fillRect(
          mario.x + 6,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          20,
          baseHeight - (mario.powerLevel === 0 ? 16 : 24)
        );

        // Body (white)
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(mario.x + 8, mario.y + 8, 16, baseHeight - 16);

        // Head (white/beige)
        ctx.fillStyle = "#FFE4C4";
        ctx.fillRect(mario.x + 6, mario.y, 20, 16);

        // Mushroom cap (red with white spots)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 4, mario.y - 4, 24, 12);

        // White spots on cap
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(mario.x + 8, mario.y - 2, 4, 4);
        ctx.fillRect(mario.x + 16, mario.y - 2, 4, 4);
        ctx.fillRect(mario.x + 12, mario.y + 2, 4, 4);
        ctx.fillRect(mario.x + 20, mario.y + 2, 4, 4);

        // Eyes (large black dots)
        ctx.fillStyle = "#000000";
        ctx.fillRect(mario.x + 10, mario.y + 6, 4, 4);
        ctx.fillRect(mario.x + 18, mario.y + 6, 4, 4);

        // Smile
        ctx.fillStyle = "#000000";
        ctx.fillRect(mario.x + 12, mario.y + 12, 8, 2);

        // Vest buttons (yellow)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(
          mario.x + 14,
          mario.y + (mario.powerLevel === 0 ? 20 : 28),
          4,
          4
        );

        // Arms (white)
        ctx.fillStyle = "#FFE4C4";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 16 : 24),
          6,
          8
        );

        // Shoes (brown)
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(mario.x + 6, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 18, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Toad - blue flames
          ctx.fillStyle = "#0066FF";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#66B3FF";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw Bowser (playable)
      function drawBowserPlayer() {
        const baseWidth = 32;
        const baseHeight = mario.powerLevel === 0 ? 32 : 48;

        // Body (dark red/orange)
        ctx.fillStyle = "#FF6600";
        ctx.fillRect(
          mario.x + 6,
          mario.y + (mario.powerLevel === 0 ? 12 : 20),
          20,
          baseHeight - (mario.powerLevel === 0 ? 12 : 20)
        );

        // Shell spikes on back
        ctx.fillStyle = "#FFD700";
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(
            mario.x + 10 + i * 6,
            mario.y + (mario.powerLevel === 0 ? 8 : 16),
            4,
            6
          );
        }

        // Head (orange/red)
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(mario.x + 6, mario.y, 20, 16);

        // Horns (yellow)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(mario.x + 4, mario.y - 2, 4, 6);
        ctx.fillRect(mario.x + 24, mario.y - 2, 4, 6);

        // Eyes (yellow with red pupils)
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(mario.x + 10, mario.y + 4, 4, 4);
        ctx.fillRect(mario.x + 18, mario.y + 4, 4, 4);
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(mario.x + 11, mario.y + 5, 2, 2);
        ctx.fillRect(mario.x + 19, mario.y + 5, 2, 2);

        // Eyebrows (angry)
        ctx.fillStyle = "#CC4400";
        ctx.fillRect(mario.x + 8, mario.y + 2, 6, 2);
        ctx.fillRect(mario.x + 18, mario.y + 2, 6, 2);

        // Snout
        ctx.fillStyle = "#FFAA66";
        ctx.fillRect(mario.x + 10, mario.y + 10, 12, 6);

        // Fangs
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(mario.x + 12, mario.y + 14, 2, 3);
        ctx.fillRect(mario.x + 18, mario.y + 14, 2, 3);

        // Arms (orange)
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(
          mario.x + 2,
          mario.y + (mario.powerLevel === 0 ? 14 : 22),
          6,
          8
        );
        ctx.fillRect(
          mario.x + 24,
          mario.y + (mario.powerLevel === 0 ? 14 : 22),
          6,
          8
        );

        // Claws (black)
        ctx.fillStyle = "#000000";
        ctx.fillRect(mario.x + 1, mario.y + baseHeight - 6, 2, 3);
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 6, 2, 3);
        ctx.fillRect(mario.x + 26, mario.y + baseHeight - 6, 2, 3);
        ctx.fillRect(mario.x + 29, mario.y + baseHeight - 6, 2, 3);

        // Feet (orange)
        ctx.fillStyle = "#FF8800";
        ctx.fillRect(mario.x + 4, mario.y + baseHeight - 4, 8, 4);
        ctx.fillRect(mario.x + 20, mario.y + baseHeight - 4, 8, 4);

        // Power level effects
        if (mario.powerLevel === 2) {
          // Fire Bowser - orange flames
          ctx.fillStyle = "#FF8C00";
          ctx.fillRect(mario.x - 3, mario.y + 8, 4, 12);
          ctx.fillRect(mario.x + baseWidth - 1, mario.y + 8, 4, 12);
          ctx.fillStyle = "#FFA500";
          ctx.fillRect(mario.x - 2, mario.y + 6, 2, 8);
          ctx.fillRect(mario.x + baseWidth, mario.y + 6, 2, 8);
        }

        mario.width = baseWidth;
        mario.height = baseHeight;
      }

      // Draw enemies
      function drawEnemy(enemy) {
        if (enemy.type === "goomba") {
          // Goomba body - brown mushroom shape
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(enemy.x + 2, enemy.y + 8, 28, 24);

          // Goomba cap - slightly darker brown
          ctx.fillStyle = "#654321";
          ctx.fillRect(enemy.x, enemy.y, 32, 12);

          // White spots on cap (classic Goomba pattern)
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(enemy.x + 4, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 12, enemy.y + 4, 4, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 24, enemy.y + 6, 4, 4);

          // Goomba eyes - simple black dots
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 8, enemy.y + 6, 3, 3);
          ctx.fillRect(enemy.x + 21, enemy.y + 6, 3, 3);

          // Goomba feet - simple brown rectangles
          ctx.fillStyle = "#654321";
          ctx.fillRect(enemy.x + 6, enemy.y + 28, 6, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 28, 6, 4);
        } else if (enemy.type === "koopa") {
          // Koopa shell - green with darker green pattern
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x, enemy.y + 16, 32, 16);

          // Shell pattern - darker green sections
          ctx.fillStyle = "#006400";
          ctx.fillRect(enemy.x + 4, enemy.y + 18, 24, 4);
          ctx.fillRect(enemy.x + 8, enemy.y + 22, 16, 4);
          ctx.fillRect(enemy.x + 12, enemy.y + 26, 8, 4);

          // Koopa head - green with simple eyes
          ctx.fillStyle = "#32CD32";
          ctx.fillRect(enemy.x + 8, enemy.y, 16, 16);

          // Koopa eyes - simple black dots
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 10, enemy.y + 4, 2, 2);
          ctx.fillRect(enemy.x + 20, enemy.y + 4, 2, 2);

          // Simple mouth line
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(enemy.x + 12, enemy.y + 10);
          ctx.lineTo(enemy.x + 20, enemy.y + 10);
          ctx.stroke();

          // Koopa legs - simple green rectangles
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x + 6, enemy.y + 14, 6, 4);
          ctx.fillRect(enemy.x + 20, enemy.y + 14, 6, 4);
        } else if (enemy.type === "dragon") {
          // Dragon - flying enemy
          // Body - dark green
          ctx.fillStyle = "#006400";
          ctx.fillRect(enemy.x + 8, enemy.y + 8, 32, 16);

          // Wings - lighter green, flapping effect
          const wingOffset = Math.sin(Date.now() * 0.01) * 3;
          ctx.fillStyle = "#32CD32";
          // Left wing
          ctx.fillRect(enemy.x, enemy.y + 4 + wingOffset, 12, 8);
          // Right wing
          ctx.fillRect(enemy.x + 36, enemy.y + 4 - wingOffset, 12, 8);

          // Head - darker green
          ctx.fillStyle = "#004400";
          ctx.fillRect(enemy.x + 16, enemy.y, 16, 12);

          // Eyes - glowing yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 18, enemy.y + 2, 4, 4);
          ctx.fillRect(enemy.x + 26, enemy.y + 2, 4, 4);
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 19, enemy.y + 3, 2, 2);
          ctx.fillRect(enemy.x + 27, enemy.y + 3, 2, 2);

          // Horns - red
          ctx.fillStyle = "#FF0000";
          ctx.fillRect(enemy.x + 14, enemy.y - 2, 4, 6);
          ctx.fillRect(enemy.x + 30, enemy.y - 2, 4, 6);

          // Tail - green with spikes
          ctx.fillStyle = "#228B22";
          ctx.fillRect(enemy.x + 40, enemy.y + 12, 8, 4);
          // Tail spikes
          ctx.fillStyle = "#FF0000";
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(enemy.x + 42 + i * 2, enemy.y + 8, 2, 4);
          }

          // Fire breath (occasional)
          if (enemy.fireTimer > 0) {
            ctx.fillStyle = "#FF4500";
            ctx.fillRect(enemy.x + 44, enemy.y + 10, 8, 2);
            ctx.fillStyle = "#FFD700";
            ctx.fillRect(enemy.x + 46, enemy.y + 8, 4, 2);
          }
        } else if (enemy.type === "bowser") {
          // Bowser - large boss enemy
          // Body - dark red
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 8, enemy.y + 24, 48, 40);

          // Shell/back spikes - dark red with spikes
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 12, enemy.y + 16, 40, 16);
          // Spikes
          ctx.fillStyle = "#DC143C";
          for (let i = 0; i < 5; i++) {
            ctx.fillRect(enemy.x + 16 + i * 8, enemy.y + 12, 4, 8);
          }

          // Head - dark red with horns
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 16, enemy.y, 32, 24);

          // Horns - yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 12, enemy.y - 4, 6, 8);
          ctx.fillRect(enemy.x + 46, enemy.y - 4, 6, 8);

          // Eyes - glowing yellow
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(enemy.x + 20, enemy.y + 6, 6, 6);
          ctx.fillRect(enemy.x + 38, enemy.y + 6, 6, 6);
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 22, enemy.y + 8, 2, 2);
          ctx.fillRect(enemy.x + 40, enemy.y + 8, 2, 2);

          // Angry eyebrows
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 18, enemy.y + 2, 10, 2);
          ctx.fillRect(enemy.x + 36, enemy.y + 2, 10, 2);

          // Mouth/Fangs - white fangs
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(enemy.x + 24, enemy.y + 16, 4, 6);
          ctx.fillRect(enemy.x + 36, enemy.y + 16, 4, 6);

          // Arms - dark red
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x, enemy.y + 20, 12, 8);
          ctx.fillRect(enemy.x + 52, enemy.y + 20, 12, 8);

          // Legs - dark red with claws
          ctx.fillStyle = "#8B0000";
          ctx.fillRect(enemy.x + 12, enemy.y + 56, 12, 8);
          ctx.fillRect(enemy.x + 40, enemy.y + 56, 12, 8);

          // Claws - black
          ctx.fillStyle = "#000000";
          ctx.fillRect(enemy.x + 10, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 18, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 38, enemy.y + 60, 4, 4);
          ctx.fillRect(enemy.x + 46, enemy.y + 60, 4, 4);
        }
      }

      // Draw power-ups
      function drawPowerUp(powerUp) {
        if (powerUp.type === "mushroom") {
          ctx.fillStyle = "#FF69B4";
          ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
          // Spots
          ctx.fillStyle = "#FFF";
          ctx.fillRect(powerUp.x + 8, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 16, 4, 4);
        } else if (powerUp.type === "fireflower") {
          ctx.fillStyle = "#FF0000";
          ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
          // Center
          ctx.fillStyle = "#FFFF00";
          ctx.fillRect(powerUp.x + 12, powerUp.y + 12, 8, 8);
          // Petals
          ctx.fillStyle = "#FFA500";
          ctx.fillRect(powerUp.x + 8, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 8, 4, 4);
          ctx.fillRect(powerUp.x + 8, powerUp.y + 20, 4, 4);
          ctx.fillRect(powerUp.x + 20, powerUp.y + 20, 4, 4);
        }
      }

      // Draw spike obstacle
      function drawSpike(spike) {
        const x = spike.x;
        const y = spike.y;
        const w = spike.width;
        const h = spike.height;

        // Draw triangular spike
        ctx.fillStyle = "#808080"; // Gray metal color
        ctx.beginPath();
        ctx.moveTo(x, y + h); // Bottom left
        ctx.lineTo(x + w / 2, y); // Top center (point)
        ctx.lineTo(x + w, y + h); // Bottom right
        ctx.closePath();
        ctx.fill();

        // Add highlight
        ctx.fillStyle = "#A0A0A0";
        ctx.beginPath();
        ctx.moveTo(x + 3, y + h);
        ctx.lineTo(x + w / 2, y + 3);
        ctx.lineTo(x + w / 2, y + h);
        ctx.closePath();
        ctx.fill();

        // Add dark edge
        ctx.strokeStyle = "#404040";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + h);
        ctx.lineTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h);
        ctx.stroke();

        // Base
        ctx.fillStyle = "#505050";
        ctx.fillRect(x, y + h - 4, w, 4);
      }

      // Draw falling rock
      function drawFallingRock(rock) {
        ctx.save();
        ctx.translate(rock.x + rock.width / 2, rock.y + rock.height / 2);
        ctx.rotate(rock.rotation);

        // Main rock body - irregular shape
        ctx.fillStyle = "#8B4513"; // Brown
        ctx.fillRect(
          -rock.width / 2,
          -rock.height / 2,
          rock.width,
          rock.height
        );

        // Add texture/cracks
        ctx.fillStyle = "#654321";
        ctx.fillRect(
          -rock.width / 4,
          -rock.height / 3,
          rock.width / 4,
          rock.height / 3
        );
        ctx.fillRect(
          rock.width / 6,
          rock.height / 6,
          rock.width / 4,
          rock.height / 4
        );

        // Highlight
        ctx.fillStyle = "#A0522D";
        ctx.fillRect(
          -rock.width / 3,
          -rock.height / 2,
          rock.width / 3,
          rock.height / 4
        );

        // Outline
        ctx.strokeStyle = "#3E2723";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          -rock.width / 2,
          -rock.height / 2,
          rock.width,
          rock.height
        );

        ctx.restore();

        // Warning indicator above rock
        if (rock.y < 50) {
          ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.fillText("‚ö†", rock.x + rock.width / 2, 30);
        }
      }

      // Draw Bill Blaster (cannon)
      function drawBillBlaster(blaster) {
        // Main cannon body - dark gray/black
        ctx.fillStyle = "#2F2F2F";
        ctx.fillRect(blaster.x, blaster.y, blaster.width, blaster.height);

        // Cannon barrel - lighter gray
        ctx.fillStyle = "#4A4A4A";
        ctx.fillRect(
          blaster.x + 8,
          blaster.y,
          blaster.width - 16,
          blaster.height / 2
        );

        // Cannon opening - black circle
        ctx.fillStyle = "#000000";
        const openingY = blaster.y + blaster.height / 4;
        ctx.fillRect(
          blaster.x + blaster.width / 4,
          openingY,
          blaster.width / 2,
          blaster.height / 4
        );

        // Highlight on cannon
        ctx.fillStyle = "#6A6A6A";
        ctx.fillRect(blaster.x + 4, blaster.y + 4, 8, blaster.height / 3);

        // Base/stand
        ctx.fillStyle = "#1F1F1F";
        ctx.fillRect(
          blaster.x,
          blaster.y + blaster.height - 8,
          blaster.width,
          8
        );

        // Metallic rivets
        ctx.fillStyle = "#808080";
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(
            blaster.x + 10 + i * 12,
            blaster.y + blaster.height / 2,
            4,
            4
          );
        }

        // Skull icon (classic Bill Blaster design)
        ctx.fillStyle = "#FFFFFF";
        const skullX = blaster.x + blaster.width / 2 - 6;
        const skullY = blaster.y + blaster.height - 20;
        // Simple skull shape
        ctx.fillRect(skullX, skullY, 12, 8);
        // Eyes
        ctx.fillStyle = "#000000";
        ctx.fillRect(skullX + 2, skullY + 2, 3, 3);
        ctx.fillRect(skullX + 7, skullY + 2, 3, 3);
      }

      // Draw Bullet Bill (rocket)
      function drawBulletBill(bullet) {
        const facingLeft = bullet.velocityX < 0;

        // Main body - black bullet shape
        ctx.fillStyle = "#000000";
        if (facingLeft) {
          // Bullet facing left
          ctx.fillRect(bullet.x + 8, bullet.y + 4, 24, 24);
          // Pointed nose
          ctx.fillRect(bullet.x, bullet.y + 12, 8, 8);
        } else {
          // Bullet facing right
          ctx.fillRect(bullet.x, bullet.y + 4, 24, 24);
          // Pointed nose
          ctx.fillRect(bullet.x + 24, bullet.y + 12, 8, 8);
        }

        // Arms (extending from sides)
        ctx.fillStyle = "#1A1A1A";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 12, bullet.y, 8, 4); // Top arm
          ctx.fillRect(bullet.x + 12, bullet.y + 28, 8, 4); // Bottom arm
        } else {
          ctx.fillRect(bullet.x + 12, bullet.y, 8, 4); // Top arm
          ctx.fillRect(bullet.x + 12, bullet.y + 28, 8, 4); // Bottom arm
        }

        // Eyes - angry white eyes
        ctx.fillStyle = "#FFFFFF";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 10, bullet.y + 10, 6, 4);
          ctx.fillRect(bullet.x + 10, bullet.y + 18, 6, 4);
        } else {
          ctx.fillRect(bullet.x + 16, bullet.y + 10, 6, 4);
          ctx.fillRect(bullet.x + 16, bullet.y + 18, 6, 4);
        }

        // Pupils - black dots
        ctx.fillStyle = "#000000";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 11, bullet.y + 11, 2, 2);
          ctx.fillRect(bullet.x + 11, bullet.y + 19, 2, 2);
        } else {
          ctx.fillRect(bullet.x + 19, bullet.y + 11, 2, 2);
          ctx.fillRect(bullet.x + 19, bullet.y + 19, 2, 2);
        }

        // Mouth/grimace
        ctx.fillStyle = "#FFFFFF";
        if (facingLeft) {
          ctx.fillRect(bullet.x + 8, bullet.y + 14, 6, 4);
        } else {
          ctx.fillRect(bullet.x + 18, bullet.y + 14, 6, 4);
        }

        // Exhaust flame effect at back
        const time = Date.now() * 0.02;
        const flameSize = 4 + Math.sin(time) * 2;
        ctx.fillStyle = "#FF4500";
        if (facingLeft) {
          ctx.fillRect(
            bullet.x + 28,
            bullet.y + 14 - flameSize / 2,
            flameSize,
            flameSize
          );
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(
            bullet.x + 30,
            bullet.y + 15 - flameSize / 4,
            flameSize / 2,
            flameSize / 2
          );
        } else {
          ctx.fillRect(
            bullet.x - flameSize,
            bullet.y + 14 - flameSize / 2,
            flameSize,
            flameSize
          );
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(
            bullet.x - flameSize / 2,
            bullet.y + 15 - flameSize / 4,
            flameSize / 2,
            flameSize / 2
          );
        }
      }

      // Start the game when page loads
      window.onload = init;
    </script>
  </body>
</html>
